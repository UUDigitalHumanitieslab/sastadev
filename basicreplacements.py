from collections import defaultdict
from metadata import bpl_word, bpl_node
from deregularise import correctinflection
from typing import Dict, List, Tuple
from sastatypes import ReplacementMode

BasicExpansion = Tuple[str, List[str], str, str, str]
BasicReplacement = Tuple[str, str, str, str, str]
KnownReplacement = Tuple[str, str, str, str, str, ReplacementMode]

pron = 'Pronunciation'
orth = 'Orthography'
infpron = 'Informal Pronunciation'
initdev = 'Initial Devoicing'
codared = 'Coda Reduction'
apomiss = 'Missing Apostrophe'
addschwa = 'Schwa addition'
onsetred = 'Onset Reduction'
d_er = 'd-onset on er'
spellerr = 'Spelling Error'
varpron = 'Alternative Pronunciation'
pronerr = 'Wrong Pronunciation'
contract = 'Contraction'
t_ie = 't-Insertion with ie'
fndrop = 'Final n drop'
zdev = 'Devoicing of /z/'
wrongpron = 'Wrong Prunciation'
phonrepl = '/{wrong}/ instead of /{correct}/'
wronginfl = 'Incorrect inflection'
morph = 'Morphology'
overgen = 'Overgeneralisation'
typo = 'Typo'
typorepl = '{wrong} instead of {correct}'

#: The constant *Rvzlist* contains a list of adpositions that can combine with *er* into
#: a so-called pronominal adverb. Example: *van*, since *er* + * van* = *ervan*.
Rvzlist = ['aan', 'achter', 'achteraan', 'achterin', 'achterop', 'af', 'beneden', 'benevens', 'bij', 'binnen',
           'binnenuit', 'boven', 'bovenaan', 'bovenin', 'bovenop', 'buiten', 'dichtbij', 'door', 'doorheen', 'heen',
           'in', 'langs', 'langsheen', 'langszij', 'mede', 'mee', 'middendoor', 'na', 'naar', 'naartoe', 'naast',
           'nabij', 'neer', 'om', 'omheen', 'onder', 'onderaan', 'op', 'over', 'overheen', 'rond', 'rondom', 'tegen',
           'tegenaan', 'tegenin', 'tegenover', 'toe', 'tussen', 'tussenin', 'tusssen', 'uit', 'van', 'vanaf',
           'vandaan', 'vandoor', 'vanop', 'vanuit', 'vanwege', 'vlakbij', 'voor', 'vooraan', 'voorbij', 'zonder']

#: The constant *ervzvariants* contains a list of 5-tuples (type *BasicReplacement*)
#: for variants of *er* (*der*, *d'r*) plus an adposition. The list is generated by using
#: the constant *Rvzlist*
#:
#: .. autodata:: basicreplacements::Rvzlist
#:        :no-value:
#:
ervzvariants : List[BasicReplacement] = \
               [('der' + vz, 'er' + vz, pron, varpron, d_er) for vz in Rvzlist] + \
               [("d'r" + vz, 'er' + vz, pron, varpron, d_er) for vz in Rvzlist]

#: The constant *basicreplacementlist* contains 5-tuples of strings with:
#:
#: * frequent deviant spelling of a word, usually to indicate how the word was (incorrectly) pronounced. together with (e.g. "as", "effe")
#: * the correct spelling of the word ("als", "even")
#: * linguistic level (e.g Pronunciation, Orthography)
#: * characterisation of the deviancy, e.g. "Informal Pronunciation", "Wrong Pronunciation"
#: * details about the deviation, e.g. "Coda Reduction", "Initial Devoicing"
#:
#: It also includes variants of R-pronouns + adposition, e.g. *dervan* or *d'rvan*
#: instead of *ervan* for all adpositions that allow an R-pronoun. It derives these by
#: using the constant *ervzvariants*
#:
#: .. autodata:: basicreplacements::ervzvariants
#:       :no-value:
basicreplacementlist: List[BasicReplacement] = [('as', 'als', pron, infpron, codared),
                                                ('isse', 'is', pron, infpron, addschwa),
                        ('ooke', 'ook', pron, infpron, addschwa),
                        ('t', "'t", orth, spellerr, apomiss), ('effjes', 'eventjes', pron, infpron, varpron),
                        ('effetjes', 'eventjes', pron, infpron, varpron),
                        ('effe', 'even', pron, infpron, varpron),
                        ('set', 'zet', pron, infpron, initdev), ('hie', 'hier', pron, pronerr, codared),
                        ('eers', 'eerst', pron, pronerr, codared),
                        ('era', 'eraf', pron, pronerr, codared),
                        ('il', 'wil', pron, pronerr, onsetred),
                        ('tee', 'twee', pron, pronerr, onsetred),
                        ('nie', 'niet', pron, infpron, codared),
                        ('s', 'is', orth, spellerr, apomiss), ('ooke', 'ook', pron, infpron, addschwa),
                        ('it', 'dit', pron, pronerr, onsetred),
                        ('da', 'dat', pron, infpron, codared),
                        ('si', 'zit', pron, infpron, codared),  # and zdev
                        ('ieduleen', 'iedereen', pron, wrongpron, phonrepl.format(wrong='l', correct='r')),
                        ('allemaaw', 'allemaal', pron, wrongpron, phonrepl.format(wrong='w', correct='l')),
                        ('amaal', 'allemaal', pron, infpron, varpron),
                        ('wiw', 'wil', pron, wrongpron, phonrepl.format(wrong='w', correct='l')),
                        ('annug', 'ander', pron, wrongpron, phonrepl.format(wrong='nug', correct='der')),
                        ('nohug', 'nodig', pron, wrongpron, phonrepl.format(wrong='hu', correct='di')),
                        ('magge', 'mogen', morph, wronginfl, '{} & {}'.format(overgen, infpron)),
                        ('maggen', 'mogen', morph, wronginfl, overgen),
                        ('aleen', 'alleen', orth, typo, typorepl.format(wrong='alleen', correct='alleen'))
                        ] + ervzvariants
# ('inne', 'in', pron, infpron, addschwa) # put off because it blocks inne -> in de

#: The dictionary *basicreplacements* maps a word with deviant orthography to a list of
#: 4-tuples containing the correct orthography and 3 strings to encode metadata. The
#: dictionary is derived from the constant *basicreplacementlist*
#:
#: .. autodata:: basicreplacements::basicreplacementlist
#:       :no-value:
#:
basicreplacements: Dict[str, List[Tuple[List[str], str, str, str]]] = defaultdict(list)
for w1, w2, c, n, v in basicreplacementlist:
    basicreplacements[w1].append((w2, c, n, v))


#: The constant *basicexpansionlist* contains 5-tuples  with:
#:
#: * frequent contracted spelling of a word sequence, usually to indicate how the word was actually (possibly incorrectly) pronounced, (e.g. "innu", "das")
#: * the correct expansion of the word as a list of strings (["in", "de"], ["dat", "is"])
#: * linguistic level (e.g "Pronunciation", "Orthography")
#: * characterisation of the deviancy, e.g. "Informal Pronunciation"
#: * details about the deviancy, e.g. "Contraction"
#:
basicexpansionlist: List[BasicExpansion] = \
                     [('innu', ['in', 'de'], pron, infpron, contract),
                      ('inne', ['in', 'de'], pron, infpron, contract),
                      ('dis', ['dit', 'is'], pron, infpron, contract),
                      ('das', ['dat', 'is'], pron, infpron, contract),
                      ('tis', ['dit', 'is'], pron, infpron, contract),
                      ('waas', ['waar', 'is'], pron, infpron, contract),
                      ('is-t-ie', ['is', 'ie'], pron, infpron, t_ie),
                      ('als-t-ie', ['als', 'ie'], pron, infpron, t_ie),
                      ('of-t-ie', ['of', 'ie'], pron, infpron, t_ie),
                      ('as-t-ie', ['als', 'ie'], pron, infpron, t_ie)]

#: The dictionary *basicexpansions* maps a contracted word form to a list of 4-tuples
#: containing its expansion as a list of words, plus 3 strings to encode metadata. The
#: dictionary is derived from the constant *basicexpansionlist*:
#:
#: .. autodata:: basicreplacements::basicexpansionlist
#:       :no-value:
#:
basicexpansions: Dict[str, List[Tuple[List[str], str, str, str]]] = defaultdict(list)
for (w1, w2, c, n, v) in basicexpansionlist:
    basicexpansions[w1].append((w2, c, n, v))

knownreplacements: List[KnownReplacement] = [
    ('ze', "z'n", pron, infpron, fndrop, bpl_word),
    ('desu', 'deze', pron, infpron, zdev, bpl_word),
    ('mij', 'mijn', pron, infpron, fndrop, bpl_word),

]

knownreplacementsdict: Dict[Tuple[str, str], KnownReplacement] = {(repl[0], repl[1]): repl for repl in knownreplacements}


def getmeta4CHATreplacements(wrongword: str, correctword: str) -> KnownReplacement:
    if (wrongword, correctword) in knownreplacementsdict:
        result = knownreplacementsdict[(wrongword, correctword)]
    else:
        nwms = correctinflection(wrongword)
        if nwms != []:
            for nw, metavalue in nwms:  # hier wordt overschreven als er meerdere resultaten zouden zijn
                if nw == correctword:
                    result = (wrongword, correctword, 'Morphology', 'InflectionError', metavalue, bpl_word)
        else:
            result = (wrongword, correctword, 'Lexicology', 'Lexical Error', 'Paraphasy',
                      bpl_word)
    return result


# keer removed
#: The constant *disambiguation_replacements* contains a list of tuples. Each tuple
#: contains  the list of words each of which should be replaced to avoid
#: ambiguity, and their replacement.
#:
#: Currently,
#:
#: * singular neuter nouns that can also be a verb form (e.g. *werk*) are replaced by the word *gas*, which only is a noun;
#: * singular uter nouns that can also be a verb form (e.g. *puzzel*) are replaced by the word *teil*, which is only a noun;
#: * plural nouns that can also be a verb (e.g. *planten*) are replaced by the word *teilen*, which is only a noun;
#: * adjectives without an *-e* ending that can also be a verb (e.g. *dicht*) are replaced by the word *mooi*, which is only an adjective;
#: * adjectives with an *-e* ending that can also be a verb (*e.g. witte*) are replaced by the word *mooie*, which is only an adjective.
#:
#: **Remark** Currently no distinction is made between singular *count* and singular *mass* nouns: they are both replaced by the same word. This may have to be adapted.
disambiguation_replacements: List[Tuple[List[str], str]] = \
                              [(['huis', 'water', 'paard', 'werk', 'stuur', 'feest', 'snoep', 'geluid',
                                 'kwartet', 'kruis'], 'gas'),
                               (['toren', 'fiets', 'puzzel', 'boom', 'vis', 'melk', 'zon', 'pot', 'klok',
                                 'school', 'boer', 'lepel', 'jas', 'tuin', 'fles', 'lucht', 'emmer', 'maan', 'kachel',
                                 'kwak', 'verf', 'hop', 'kam', 'spiegel', 'klap', 'stal', 'lijm', 'lift', 'kat',
                                 'wagen', 'schep', 'kus', 'wind', 'borstel', 'duim', 'strik', 'klik', 'pleister',
                                 'stok', 'knoop', 'rits', 'knikker', 'put', 'boor', 'plons', 'beurt', 'toeter', 'poot',
                                 'punt', 'post', 'gom', 'tap', 'kraanwagen', 'drup', 'wieg', 'kriebel', 'pit', 'zaag',
                                 'slof', 'deuk', 'hark', 'jeuk', 'stift', 'aard', 'hamster', 'kiek', 'haak', 'schroef',
                                 'tape', 'vorm', 'klem', 'mot', 'druppel'], 'teil'),
                               (['bomen', 'kussen', 'kaarten', 'beesten', 'weken', 'huizen', 'apen', 'poten',
                                 'wieken', 'paarden', 'stoelen', 'ramen', 'strepen', 'planten', 'groeten',
                                 'flessen', 'boeren', 'punten', 'tranen'], 'teilen'),
                               (['snel', 'wit', 'kort', 'dicht'], 'mooi'),
                               (['witte'], 'mooie')
                               ]


def getdisambiguationdict() -> Dict[str, str]:
    '''
    :return: a dictionary with word:replacement items (both of type string)

    The function *getdisambiguationdict* creates a dictionary with word:replacement
    items. It selects its content from the constant *disambiguation_replacements*:

    .. autodata:: basicreplacements::disambiguation_replacements
         :no-value:
    '''
    disambiguationdict = {}
    for ws, repl in disambiguation_replacements:
        for w in ws:
            disambiguationdict[w] = repl
    return disambiguationdict
