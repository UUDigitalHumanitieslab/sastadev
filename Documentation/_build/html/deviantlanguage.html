
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Deviant Language &#8212; SASTA  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Auxiliary Modules" href="auxiliarymodules.html" />
    <link rel="prev" title="Lexicons" href="lexicons.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="auxiliarymodules.html" title="Auxiliary Modules"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lexicons.html" title="Lexicons"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SASTA  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Deviant Language</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="deviant-language">
<h1>Deviant Language<a class="headerlink" href="#deviant-language" title="Permalink to this heading">¶</a></h1>
<p>The input for SASTA contains a lot of deviant language. Language is of course deviant when it does not adhere to the rules of the Dutch language.
But since in SASTA Alpino is the approximation of these rules, what really counts as deviant is what is deviant relative to the Alpino grammar. We will see several examples of this below.</p>
<p>Deviant language can be avoided by using CHAT-annotations. But CHAT-annotations are not always used, and even if they are  used, they are not used
systematically and consistently.</p>
<p>We will first describe the general strategy that SASTA follows to deal with deviant language.</p>
<section id="general-strategy">
<h2>General Strategy<a class="headerlink" href="#general-strategy" title="Permalink to this heading">¶</a></h2>
<p>We first give a global overview of the strategy followed, and illustrate it with a simple example. This involves the following steps:</p>
<ol class="arabic simple">
<li><p>It is assumed that the whole sample has been parsed as is, and has resulted in a treebank.</p></li>
<li><p>An attempt is made to identify a deviant configuration in each utterance in the treebank that has to be analysed. This is usually done by identifying specific patterns in the input string. The procedure can also investigate the syntactic structure, and this is used, but its use is limited because the syntactic structure is usually not very informative exactly because of the deviancy in the utterance. For example, in the utterance <em>bij die varken</em>, SASTA should identify deviant language (the <em>de</em>-word <em>die</em> is immediately followed by a <em>het</em>-word (<em>varken</em>).</p></li>
<li><p>SASTA attempt to make a correction, or even multiple alternative corrections. So <em>bij die varken</em> is replaced by <em>bij dat varken</em>, with <em>die</em> replaced by <em>dat</em>. SASTA also adds metadata to reflect this correction. These corrections can involve replacements of one word by another word, insertions of a word, deletions of a word or word sequence, or expansion of a word into a sequence of words. Of course, multiple corrections can be applied to a single utterance.</p></li>
<li><p>SASTA parses the corrected utterance(s).</p></li>
<li><p>It then evaluates the original and corrected utterances, by a complex evaluation measure, which involves inter alia the degree of grammatical cohesion, the number of deviant configurations present, and the number of unknown words present.</p></li>
<li><p>SASTA selects the best one, with its metadata</p></li>
<li><p>SASTA then replaces the corrections by the original words, sometimes with the properties of the original word in the parse of the corrected utterance. In the example, the correction <em>dat</em> is replaced by the original word <em>die</em> (and its grammatical properties), so that the utterance has the syntactic structure of the utterance  <em>bij dat varken</em>, but contains the word <em>die</em> (with its properties) instead of <em>dat</em> (and its properties).</p></li>
<li><p>The grammatical analysis of the relevant method is applied, in the normal way.</p></li>
<li><p>SASTA generates, on the basis of the metadata produced,  an error report, which specifies each error that has been found, how it has been corrected, and some additional information.</p></li>
<li><p>SASTA also generates an error logging file, which specifies all the alternatives that have been considered, and which one is considered the best one according to the evaluation criterion.</p></li>
</ol>
<p>A corrected treebank is generated by a call in <em>sastadev</em> to the function <em>correcttreebank</em> in the module <em>correcttreebank</em>:</p>
<dl class="py function">
<dt class="sig sig-object py" id="correcttreebank.correcttreebank">
<span class="sig-prename descclassname"><span class="pre">correcttreebank.</span></span><span class="sig-name descname"><span class="pre">correcttreebank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">treebank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'n'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Element</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">OrigandAlts</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/correcttreebank.html#correcttreebank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#correcttreebank.correcttreebank" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>correcttreebank</em> takes as input:</p>
<ul class="simple">
<li><p>treebank: the treebank of the sample, parsed as is.</p></li>
<li><p>targets: a specification of the utterances that have to be analysed</p></li>
<li><p>method: the method to be used. Some corrections are method-specific</p></li>
<li><p>corr: to indicate how the corrections should be done: no corrections at all, all corrections but the last one (usually the one with most adaptations) is selected; all  corrections but the best one according to the evaluation  criterion is selected.</p></li>
</ul>
<p>It returns a triple consisting of</p>
<ul class="simple">
<li><p>the corrected treebank</p></li>
<li><p>an error dictionary: a list of errors detected and how they have corrected</p></li>
<li><p>a list of all original utterances and all alternatives that have been considered</p></li>
</ul>
</dd></dl>

<p>Each syntactic structure in the input treebank is corrected by the function <em>correct_stree</em> in the module <em>correcttreebank</em>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="correcttreebank.correct_stree">
<span class="sig-prename descclassname"><span class="pre">correcttreebank.</span></span><span class="sig-name descname"><span class="pre">correct_stree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Element</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">OrigandAlts</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/correcttreebank.html#correct_stree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#correcttreebank.correct_stree" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>The function <em>correct_stree</em> takes as input:</p>
</div></blockquote>
<ul class="simple">
<li><p>stree: input syntactic structure</p></li>
<li><p>method:  MethodName (tarsp, asta, stap)</p></li>
<li><p>corr: CorrectionMode (corr0, corr1, corrn)</p></li>
</ul>
<p>and returns a tuple consisting of:</p>
<ul class="simple">
<li><p>the corrected syntactic structure</p></li>
<li><p>optionally a specification of the original utterance and all alternatives  considered</p></li>
</ul>
<p>The following steps are carried out:</p>
<p>1. The original utterance, with all CHAT-annotations, is cleaned using the function <em>cleantext</em> from the module
<em>cleanCHILDEStokens</em>. This is necessary to generate the metadata for the CHAT-annotations, but it can be
discarded when the original parses use the same <em>cleantext</em> function. Currently that is not possible yet because
the original parsing is done via GrETEL modules, which cannot handle complex metadata (xmeta). The result of
this operation is a list of tokens of type <em>Token</em> as defined in the module <em>sastatoken</em>. &#64;&#64;add ref&#64;&#64;</p>
<ol class="arabic simple" start="2">
<li><p>Alpino parses are inflated to be able to deal easily with insertions and deletions. &#64;&#64;add ref&#64;&#64;</p></li>
<li><p>The corrections are obtained by calling the function <em>getcorrections</em> from the module <em>corrector</em></p></li>
</ol>
<p>4. The corrections may have tokens that are marked with skip=True, in which case they should not be included in the
corrected utterance, so  a corrected utterance with these words left out is created.</p>
<ol class="arabic simple" start="5">
<li><p>Each corrected utterance  is parsed, resulting in an inflated syntactic structure.</p></li>
</ol>
<p>6. Words that were left out are now introduced into the syntactic structure, in such a way that they have no
grammatical relations with other words.</p>
<p>7. The best alternative is selected from among the original utterance and the generated corrected utterances by
the function <em>selectcorrection</em> from the module <em>correcttreebank</em>.</p>
<p>8. The original words and sometimes their properties are now substituted for the corrections. The exact nature of
the replacement is determined by the value of the <em>backplacement</em> attribute of the metadata. Expansions are not
replaced yet, because they must be replaced only after the queries have been executed. Nodes for words that have
to be deleted are collected, but the actual deletion only takes place in the next step.</p>
<p>9. Words that were marked to be deleted are now all deleted, by the function <em>deletewordnodes</em> of the module
<em>treebankfunction</em>.</p>
<ol class="arabic simple" start="10">
<li><p>The metadata are updated and added to the syntactic structure.</p></li>
</ol>
<p>11. During the whole process the mapping between the nodes for words in the original syntactic structure and the
nodes for words in the syntactic structure for the corrected utterance must be perfect. A check is performed
to determine whether this is the case.</p>
<p>12. Finally, the corrected syntactic structure and the specification of the original utterance and all alternatives
considered is returned.</p>
</dd></dl>

<p>Since in the corrected utterance multiple words may have to be inserted or removed, and since the linear order in Alpino syntactic structures is indicated by means of <em>begin</em> and <em>end</em> attributes (see <a class="reference internal" href="alpinoparser.html#alpinoparser"><span class="std std-ref">Alpino parser</span></a>), SASTA uses “inflated” syntactic structures, i.e syntactic structures in which the <em>begin</em> attribute of the first original word has the value <em>‘10’</em>, and the <em>begin</em> attribute of the next word has the value <em>‘20’</em>. The values of the <em>end</em> attribute are equal to str(int(begin) + 1 ), as usual. This enables one to delete and insert nodes for words without having to adapt the <em>begin</em> and <em>end</em> values of each node. Inflating a syntactic structure in this way is done by the function <em>treeinflate</em> in the module treebankfunctions.</p>
<dl class="py function">
<dt class="sig sig-object py" id="treebankfunctions.treeinflate">
<span class="sig-prename descclassname"><span class="pre">treebankfunctions.</span></span><span class="sig-name descname"><span class="pre">treeinflate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/treebankfunctions.html#treeinflate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#treebankfunctions.treeinflate" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>treeinflate</em> adapts the input tree <em>stree</em> in such a way that:</p>
<ul class="simple">
<li><p>for word nodes: the int value of the <em>begin</em> attribute o (ib) is changed to str(newib =(ib + 1) * inc), and the value of the <em>end</em> attribute to str(newib + 1)</p></li>
<li><p>for phrasal nodes: new values for <em>begin</em> and <em>end</em> are computed by the function <em>getbeginend</em></p></li>
<li><p>for other nodes: the same as  for word nodes</p></li>
</ul>
<p>The parameters of this function are:</p>
<ul class="simple">
<li><p>stree: input syntactic structure, which is modified</p></li>
<li><p>start: not used yet and probably not necessary (default value = 10)</p></li>
<li><p>inc: increment, by default set to 10 (not used yet)</p></li>
</ul>
<p>and it returns <em>None</em>.</p>
</dd></dl>

</section>
<section id="various-types-of-deviant-language">
<h2>Various Types of Deviant Language<a class="headerlink" href="#various-types-of-deviant-language" title="Permalink to this heading">¶</a></h2>
<p>Deviant language occurs in many different forms. We discuss the most important ones here.</p>
<section id="deviant-transcriptions">
<h3>Deviant Transcriptions<a class="headerlink" href="#deviant-transcriptions" title="Permalink to this heading">¶</a></h3>
<p>We give the transcription, the correct transcription after a slash, a translation between round brackets,
the reason why the transcription is deviant, and how and where this is dealt with</p>
<section id="final-n-not-pronounced-after-schwa">
<h4>Final n not pronounced after schwa<a class="headerlink" href="#final-n-not-pronounced-after-schwa" title="Permalink to this heading">¶</a></h4>
<p>Example: <em>mouwe</em> /      <em>mouwen</em> (sleeves): This is dealt with in the function <em>getalternativetokenmds</em> in the module corrector.</p>
</section>
<section id="dee">
<h4>Dee<a class="headerlink" href="#dee" title="Permalink to this heading">¶</a></h4>
<p>The string <em>dee</em> must sometimes be interpreted as <em>deze</em> (this), sometimes as <em>deed</em> (did). Both alternatives are generated in the function <em>getalternativetokenmds</em> in the module corrector.</p>
</section>
<section id="moe">
<h4>Moe<a class="headerlink" href="#moe" title="Permalink to this heading">¶</a></h4>
<p>The string <em>moe</em> must sometimes be interpreted literally  as <em>moe</em> (tired), sometimes as <em>moet</em> (must). If <em>moe</em> is used as <em>moet</em> in an utterance, Alpino usually cannot make anything of it.  We have defined a query to identify occurrences of <em>moe</em> that has no grammatical connections, and then replace it with <em>moet</em> as one alternative.</p>
</section>
<section id="verb-form-ie-written-as-one-word">
<h4>Verb form + <em>ie</em> written as one word<a class="headerlink" href="#verb-form-ie-written-as-one-word" title="Permalink to this heading">¶</a></h4>
<p>Example: <em>gaatie</em>       / <em>gaat ie</em> (goes he): probably written as one word because it is pronounced as one word. This is dealt with by the <em>gaatie</em> function in the corrector module:</p>
<blockquote>
<div><ul>
<li><dl class="py function">
<dt class="sig sig-object py" id="corrector.gaatie">
<span class="sig-prename descclassname"><span class="pre">corrector.</span></span><span class="sig-name descname"><span class="pre">gaatie</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/corrector.html#gaatie"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#corrector.gaatie" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>gaatie</em> replaces  a word that matches with the gaatiepattern by a sequence of two words where
the first word equals word[:-2] and the second word equals word[-2:]</p>
</dd></dl>

</li>
</ul>
</div></blockquote>
</section>
<section id="dehyphenation">
<h4>Dehyphenation<a class="headerlink" href="#dehyphenation" title="Permalink to this heading">¶</a></h4>
<ul>
<li><p><em>zie-ken-huis</em> / <em>ziekenhuis</em> (hospital):     syllables pronounced separately (used mostly in ASTA). This is dealt with in  the function <em>getalternativetokenmds</em> in the module corrector by a call to the function fullworddehyphenate:</p>
<blockquote>
<div><ul>
<li><dl class="py function">
<dt class="sig sig-object py" id="stringfunctions.fullworddehyphenate">
<span class="sig-prename descclassname"><span class="pre">stringfunctions.</span></span><span class="sig-name descname"><span class="pre">fullworddehyphenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inlexicon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stringfunctions.html#fullworddehyphenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stringfunctions.fullworddehyphenate" title="Permalink to this definition">¶</a></dt>
<dd><p>The function fullworddehyphenate takes as input a string <em>word</em>:</p>
<p>Its purpose is to remove unnecessary hyphens from this word.</p>
<ul class="simple">
<li><p>the hyphen can be a part of the word (<em>sergeant-majoor</em>), in which case it should not be removed.</p></li>
<li><p>it can also have been added to an existing word without hyphens (zie-ken-huis), in which case, it should be removed</p></li>
<li><p>it can also separate a possibly mispronounced prefix repetition of the prefix of word (e.g., ver-verkoopt or vver-verkoopt), in which case the hyphen and the prefix should be removed.</p></li>
</ul>
<p>To that end,</p>
<ul class="simple">
<li><p>it applies the function <em>dehyphenate</em> to <em>word</em>. If this yields a result that is an existing word according to the function <em>inlexicon</em>, then this result is added to the result variable <em>newtokens</em></p></li>
<li><p>if newtokens is still the empty list after this, it applies the function <em>delhyphenprefix</em> to word.  If this yields a result that is an existing word according to the function <em>inlexicon</em>, then this result is added to the result variable <em>newtokens</em>.</p></li>
</ul>
<p>and then it returns the result variable newtokens.</p>
<p>The functions <em>dehyphenate</em> and <em>delhyphenprefix</em> are described here:</p>
<ul>
<li><dl class="py function">
<dt class="sig sig-object py" id="stringfunctions.dehyphenate">
<span class="sig-prename descclassname"><span class="pre">stringfunctions.</span></span><span class="sig-name descname"><span class="pre">dehyphenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stringfunctions.html#dehyphenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stringfunctions.dehyphenate" title="Permalink to this definition">¶</a></dt>
<dd><p>The function dehyphenate takes as input a string and returns  a list of strings with all possible ways
of removing hyphens in this string
Examples:</p>
<ul class="simple">
<li><p>dehyphenate(‘zie-ken-huis’) = [‘zie-ken-huis’, ‘zieken-huis’, ‘zie-kenhuis’, ‘ziekenhuis’]</p></li>
<li><p>dehyphenate(‘ziekenhuis’) = [‘ziekenhuis’]</p></li>
<li><p>dehyphenate(’—’) = [’—’]  (a string consisting only of hyphens remains unchanged</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py function">
<dt class="sig sig-object py" id="stringfunctions.delhyphenprefix">
<span class="sig-prename descclassname"><span class="pre">stringfunctions.</span></span><span class="sig-name descname"><span class="pre">delhyphenprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inlexicon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stringfunctions.html#delhyphenprefix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stringfunctions.delhyphenprefix" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>delphyphenprefix</em> takes as input a string <em>word</em>, splits it into a prefix and a mainword
based on the first occurring hyphen, and  then:</p>
<ul class="simple">
<li><p>if the prefix is a prefix that normally occurs with a hyphen and the mainword is an existing word according to the function <em>inlexicon</em> (e.g. <em>ex-vrouw</em>), the result variable is set to the empty list;</p></li>
<li><p>if the mainwords starts with the prefix and the main word is an existing word according to the function <em>inlexicon</em> (e.g. <em>ver-verkoop</em>),  then the result variable is set to [mainword];</p></li>
<li><p>if the prefix and the mainword are both existing words, the result variable is set to [];</p></li>
<li><p>if the mainwords starts with barededeup(prefix) and the main word is an existing word according to the function <em>inlexicon</em> (e.g. <em>vver-verkoop</em>),  then the result variable is set to [mainword]</p></li>
</ul>
<blockquote>
<div><p>and then it returns the value of the result variable <em>result</em>.</p>
</div></blockquote>
</dd></dl>

</li>
</ul>
</dd></dl>

</li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
</section>
<section id="regional-informal-spoken-language">
<h3>(Regional) informal spoken language<a class="headerlink" href="#regional-informal-spoken-language" title="Permalink to this heading">¶</a></h3>
<section id="module-iedims">
<span id="ie-diminutives"></span><h4><em>ie</em>-diminutives<a class="headerlink" href="#module-iedims" title="Permalink to this heading">¶</a></h4>
<p>The module <em>iedims</em> deals with diminutive forms ending in <em>-ie</em>. Alpino cannot deal with such diminutives,
but the function <em>getjeforms</em> finds for a given word ending in <em>-ie</em> what the corresponding diminutives ending in
<em>-je</em> are.
There can be many, e.g. <em>kassie</em> can correspond to <em>kasje</em> but also to <em>kastje</em>.</p>
<p>To our knowledge, there are no established orthographic rules for these forms. Therefore we should be robust to
several alternative ways of writing these forms, e.g.</p>
<ul class="simple">
<li><p>Kees: Keesie, Keessie, or Kesie?: all are accepted</p></li>
<li><p>Huub: Huupie, Huuppie, or Hupie?: all are accepted</p></li>
<li><p>wijf: wijfie, or wijffie?: we allow both</p></li>
<li><p>feest: fesie, feesie, or feessie?: we require <em>feessie</em> or <em>feesie</em></p></li>
<li><p>dag: daggie, or dachie? : we require <em>daggie</em></p></li>
<li><p>truc: trucie, truuccie, truukkie, or  trukie?: we cannot deal with any at this moment</p></li>
<li><p>maag: magie or maaggie, maachie?: we allow <em>magie</em> or <em>maaggie</em></p></li>
<li><p>vaas: vasie or vaassie?: both are allowed</p></li>
</ul>
<p>The module has been tested against a gold reference of all words ending in ie(s) from OpenSonaR.
The module to use for a renewed test is tests.iedims_test.py, the file is tests.iediminutives.iedimsgold2.csv</p>
<dl class="py function">
<dt class="sig sig-object py" id="iedims.getjeforms">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">getjeforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ieform</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/iedims.html#getjeforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#iedims.getjeforms" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>getjeforms</em> when applied to a string  returns a list of strings that are diminutives ending in
<em>-je</em> of which the lemma occurs in the lexicon. If no such string is found, it returns the empty list.</p>
<p>It crucially makes use of the functions <em>getjeformsnolex</em> and <em>getbase</em></p>
<dl class="py function">
<dt class="sig sig-object py" id="iedims.getjeformsnolex">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">getjeformsnolex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ieform</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/iedims.html#getjeformsnolex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#iedims.getjeformsnolex" title="Permalink to this definition">¶</a></dt>
<dd><p>The function getjeformsnolex when applied to a string <em>ieform</em> returns a list of candidate
diminutive strings ending in <em>-je</em> corresponding to  <em>ieform</em>. If no such candidates are found, it returns the
empty list.</p>
<p>The function applies a range of relevant regular expressions for <em>ie</em>-diminutives, and, if a match is found,
it applies one or more appropriate replacements.</p>
<p>The relevant regular expressions are:</p>
<dl class="py data">
<dt class="sig sig-object py" id="iedims.cvcicipattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">cvcicipattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([bcdfghjklmnpqrstvwxz]|^)([aeiouy])([pfksg])\\4(ie)(s?)$'</span></em><a class="headerlink" href="#iedims.cvcicipattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> CVCiCiie : ending in consonant (C), single vowel (V), two identical consonants (CiCi) and <em>ie(s)</em></p></li>
<li><p><strong>Replacement</strong> VCije: degeminate the consonants and replace <em>ie</em> by <em>je</em></p></li>
<li><p><strong>Examples</strong>: bakkie -&gt; bakje ukkie -&gt; ukje</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="iedims.dciepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">dciepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)(au|ei|eu|ie|ij|oe|ou|ui)([pfksg])ie(s?)$'</span></em><a class="headerlink" href="#iedims.dciepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> DCie : Diphthong followed by a single consonant and <em>ie(s)</em></p></li>
<li><p><strong>Replacement</strong>  V2Cje: simply replace <em>ie</em> by <em>je</em></p></li>
<li><p><strong>Examples</strong>: buikie &gt; buikje wijfie -&gt; wijfje buisie _-&gt; buisje poepie -&gt; poepje</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="iedims.vvsiepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">vvsiepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)(aa|ee|oo|uu|au|ei|eu|ie|ij|oe|ou|ui)([pfksg])ie(s?)$'</span></em><a class="headerlink" href="#iedims.vvsiepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> vvsie: the same as vvssie but now with a single consonant.</p></li>
<li><p><strong>Replacement</strong>: simply replace <em>íe</em> by <em>je</em> and <em>tje</em></p></li>
<li><p><strong>Examples</strong>: koopie -&gt; koopje, weekie -&gt; weekje, feesie -&gt; feestje, beesie -&gt; beestje</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="iedims.vvssiepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">vvssiepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)(aa|ee|oo|uu|au|ei|eu|ie|ij|oe|ou|ui)([pfksg])\\3ie(s?)$'</span></em><a class="headerlink" href="#iedims.vvssiepattern" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="iedims.vciepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">vciepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([aeiouy])([bcdfghjklmnpqrstvwxz])ie(s?)$'</span></em><a class="headerlink" href="#iedims.vciepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> vcie: vowel + consonant _ <em>ie</em></p></li>
<li><p><strong>Replacement</strong>: duplicate the vowel, replace <em>ie</em> by <em>je</em></p></li>
<li><p><strong>Examples</strong>: (‘slapie’, ‘slaapje’), (‘rapie’, ‘raapje’), (‘takie’, ‘taakje’), (‘stafie’, ‘staafje’), (‘magie’,’maagje’), (‘vasie’, ‘vaasje’)</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="iedims.chiepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">chiepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)chie(s?)$'</span></em><a class="headerlink" href="#iedims.chiepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> chie: words ending in chie(s)</p></li>
<li><p><strong>Replacement</strong>: replace <em>ie</em> by <em>je</em> and by <em>tje</em></p></li>
<li><p><strong>Examples</strong>: ‘hachie’, ‘hachje’), (‘vrachie’, ‘vrachtje’),  (‘kuchie’, ‘kuchje’)</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="iedims.cic1jiepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">cic1jiepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([bcdhjlmnqrtvwxz]p|[bcdhjlmnqrtvwxz]f|[bcdhjlmnqrtvwxz]k|[bcdhjlmnqrtvwxz]s|[bcdhjlmnqrtvwxz]g)ie(s?)$'</span></em><a class="headerlink" href="#iedims.cic1jiepattern" title="Permalink to this definition">¶</a></dt>
<dd><p>str(object=’’) -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to ‘strict’.</p>
</dd></dl>

<p>For all patterns except for the last two mentioned also a voiced replacement is carried out.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="iedims.getbase">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">getbase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/iedims.html#getbase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#iedims.getbase" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <em>getbase</em> computes a list of candidate lemmas for the input diminutive form (ending in <em>je</em>) <em>dim</em>.</p>
<p>It makes use of various patterns and replacements:</p>
<ul>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.ngetjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">ngetjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)ngetje(s?)$'</span></em><a class="headerlink" href="#iedims.ngetjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> ngetjepattern: words ending in <em>ngetje(s)</em></p></li>
<li><p><strong>Replacement</strong>: replace <em>ngetje</em> by <em>ng</em> and srop <em>s</em> if present</p></li>
<li><p><strong>Examples</strong>: (‘tekeningetje’,’tekening’), (‘tekeningetjes’, ‘tekening’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.cicietjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">cicietjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([bcdfghjklmnpqrstvwxz])\\2etje(s?)$'</span></em><a class="headerlink" href="#iedims.cicietjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> cicietje: words ending in two identical consonants followed by <em>etje(s)</em></p></li>
<li><p><strong>Replacement</strong>: keep only on consonant and drop etjes(s)</p></li>
<li><p><strong>Examples</strong>: (‘balletje’,’bal’), (‘balletjes’,’bal’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.cmpjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">cmpjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([bcdfghjklmnpqrstvwxz])mpje(s?)$'</span></em><a class="headerlink" href="#iedims.cmpjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> cmpje: words ending in consonant plus <em>mpje(s)</em></p></li>
<li><p><strong>Replacement</strong>: replace <em>mpje</em> by <em>m</em>, drop <em>s</em></p></li>
<li><p><strong>Examples</strong>: (‘armpje’, ‘arm’), (‘armpjes’, ‘arm’), (‘darmpje’, ‘darm’), (‘darmpjes’, ‘darm’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.vmpjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">vmpjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([bcdfghjklmnpqrstvwxz])((aa|ee|oo|uu|au|ei|eu|ie|ij|oe|ou|ui)|e)mpje(s?)$'</span></em><a class="headerlink" href="#iedims.vmpjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> vmpje: words ending in consonant + (two vowels or <em>e</em>) plus <em>mpje(s)</em></p></li>
<li><p><strong>Replacement</strong>: replaces <em>mpje</em> by <em>m</em>, drop <em>s</em></p></li>
<li><p><strong>Examples</strong>: (‘bloempje’,’bloem’), (‘bezempje’, ‘bezem’), (‘bloempjes’, ‘bloem’), (‘bezempjes’, ‘bezem’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.nkjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">nkjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)nkje(s?)$'</span></em><a class="headerlink" href="#iedims.nkjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> nkjepattern: words ending in <em>nkje(s)</em></p></li>
<li><p><strong>Replacement</strong>: replace <em>nkje</em> by <em>ng</em> and drop <em>s</em></p></li>
<li><p><strong>Examples</strong>: (‘koninkje’,’koning’), (‘koninkjes’,’koning’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.vivitjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">vivitjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)([aeiouy])\\2tje(s?)$'</span></em><a class="headerlink" href="#iedims.vivitjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> vivitje: words ending in two identical vowels followed by <em>tjes(s)</em></p></li>
<li><p><strong>Replacement</strong>: keep one vowel, drop <em>tje</em>, drop <em>s</em></p></li>
<li><p><strong>Examples</strong>: (‘laatje’,’la’), (‘laatjes’,’la’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.vivjtjepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">vivjtjepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)(au|ei|eu|ie|ij|oe|ou|ui)tje(s?)$'</span></em><a class="headerlink" href="#iedims.vivjtjepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> vivjtje: words ending in a diphthong followed by <em>tje(s)</em></p></li>
<li><p><strong>Replacement</strong>: drop <em>tje</em>, drop <em>s</em> if present</p></li>
<li><p><strong>Examples</strong>: (‘lelietje’,’lelie’), (‘leitje’, ‘lei’), (‘lelietjes’,’lelie’), (‘leitjes’, ‘lei’)</p></li>
</ul>
</dd></dl>

</li>
<li><dl class="py data">
<dt class="sig sig-object py" id="iedims.jepattern">
<span class="sig-prename descclassname"><span class="pre">iedims.</span></span><span class="sig-name descname"><span class="pre">jepattern</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'^(.*)je(s?)$'</span></em><a class="headerlink" href="#iedims.jepattern" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><strong>Pattern</strong> je:  words ending in <em>je(s)</em></p></li>
<li><p><strong>Replacement</strong>: drop <em>je</em>, drop <em>s</em> if present</p></li>
<li><p><strong>Examples</strong>: (‘huisje’,’huis’), (‘bakje’, ‘bak’), (‘huisjes’,’huis’), (‘bakjes’, ‘bak’)</p></li>
</ul>
</dd></dl>

</li>
</ul>
</dd></dl>

</dd></dl>

</section>
<section id="incorrect-possessive-pronouns">
<h4>Incorrect possessive pronouns<a class="headerlink" href="#incorrect-possessive-pronouns" title="Permalink to this heading">¶</a></h4>
</section>
<section id="wrong-pronunciation-of-content-words-in-the-transcript">
<h4>Wrong pronunciation of content words in the transcript<a class="headerlink" href="#wrong-pronunciation-of-content-words-in-the-transcript" title="Permalink to this heading">¶</a></h4>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Deviant Language</a><ul>
<li><a class="reference internal" href="#general-strategy">General Strategy</a></li>
<li><a class="reference internal" href="#various-types-of-deviant-language">Various Types of Deviant Language</a><ul>
<li><a class="reference internal" href="#deviant-transcriptions">Deviant Transcriptions</a><ul>
<li><a class="reference internal" href="#final-n-not-pronounced-after-schwa">Final n not pronounced after schwa</a></li>
<li><a class="reference internal" href="#dee">Dee</a></li>
<li><a class="reference internal" href="#moe">Moe</a></li>
<li><a class="reference internal" href="#verb-form-ie-written-as-one-word">Verb form + <em>ie</em> written as one word</a></li>
<li><a class="reference internal" href="#dehyphenation">Dehyphenation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regional-informal-spoken-language">(Regional) informal spoken language</a><ul>
<li><a class="reference internal" href="#module-iedims"><em>ie</em>-diminutives</a></li>
<li><a class="reference internal" href="#incorrect-possessive-pronouns">Incorrect possessive pronouns</a></li>
<li><a class="reference internal" href="#wrong-pronunciation-of-content-words-in-the-transcript">Wrong pronunciation of content words in the transcript</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="lexicons.html"
                          title="previous chapter">Lexicons</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="auxiliarymodules.html"
                          title="next chapter">Auxiliary Modules</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/deviantlanguage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="auxiliarymodules.html" title="Auxiliary Modules"
             >next</a> |</li>
        <li class="right" >
          <a href="lexicons.html" title="Lexicons"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SASTA  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Deviant Language</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Jan Odijk, Jelte van Boheemen, Martin Kroon.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>