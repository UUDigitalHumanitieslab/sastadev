
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Implementation of the methods &#8212; SASTA  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="TARSP Language Measures" href="Tarsp.html" />
    <link rel="prev" title="Alpino parser" href="alpinoparser.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Tarsp.html" title="TARSP Language Measures"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="alpinoparser.html" title="Alpino parser"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SASTA  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Implementation of the methods</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="implementation-of-the-methods">
<h1>Implementation of the methods<a class="headerlink" href="#implementation-of-the-methods" title="Permalink to this heading">¶</a></h1>
<p>The selection of the utterances to be analyzed  is currently not done by SASTA (though it probably is possible, and it is planned to experiment with it).</p>
<p>Each method is described by a set of language measures. Each language measure has a number of properties, the most prominent one of which is   the query. Each method is represented as a table in an Excel document, in a subfolder <em>methods</em> in the code folder, with the language measures in the rows and the language measure properties in the columns.</p>
<p>Each language measure has the following properties:</p>
<ul class="simple">
<li><p><strong>ID</strong> Each language measure has an ID, which consists one one letter and 3 digits. Tarsp IDs start with T, ASTA IDs start with A, and STAP IDs start with S.</p></li>
<li><p><strong>Category</strong>: Each language measure can belong to a category, for example Zinsconstructies, Verbindingswoorden, Woordgroepen in TARSP.</p></li>
<li><p><strong>Subcat</strong>: Each language measure can belong to a subcategory, e.g. Vragen, Mededelende Zinnen in TARSP.</p></li>
<li><p><strong>Level</strong>: Each language measure can belong to a level. In Tarsp this is usually an abbreviation for the Category property, e.g. Zc, Sz, VVW.</p></li>
<li><p><strong>Item</strong>: the code to use to annotate the language measure, e.g. Avn, BBX in TARSP, M, N, LEX in ASTA, VT, VN, SGG in STAP. Case is never significant in codes.</p></li>
<li><p><strong>Altitems</strong>: alternative codes that one can use to annotate the language measure, e.g. hwwi next to hww i, hww Z next to hwwZ (TARSP), del lidwoord next to dellid (ASTA), . In this way we are robust to variant notations and frequently made typo’s (e.g., BIJZ, BIJZN, BIJZIJN for BIJZIN in ASTA)</p></li>
<li><p><strong>Implies</strong>: Especially relevant in TARSP to cover specific ways of coding. Using a particular code implies that some other codes are also implicitly coded. See below for explanation. Example: coding OndWB implies coding Ond, W and B.</p></li>
<li><p><strong>Original</strong>: Possible values are yes or no. We sometimes make language measures that are not original to the method, for research or development purposes. For example, in TARSP we defined a language measure for verb-initial utterances (T054, Sv1) and for utterances without a finite verb (T122, PV-loos). This property is used to distinguish these from original language measures</p></li>
<li><p><strong>Pages</strong>: mentions the pages in the book or article that describes the method where this language measure is described.</p></li>
<li><p><strong>Fase</strong>: (used in TARSP only): stage that the language measure belongs to</p></li>
<li><p><strong>Query</strong>: the query that implements the language measure</p></li>
<li><p><strong>Inform</strong>: specifies whether the language measure appears in the form associated with the method. See below for more explanation.</p></li>
<li><p><strong>Screening</strong>: (relevant for Tarsp only) whether the query is relevant for the TARSP Screening procedure.</p></li>
<li><p><strong>Process</strong>: Language measures come in 4 process categories. Language measures with the same process category are applied in an indeterminate order and they cannot use results of other language measures from this process category. The four process categories are:</p>
<ul>
<li><p><strong>Pre</strong>: Prequeries: these are performed first</p></li>
<li><p><strong>Core</strong>: Core queries: these are performed next, and they can make use of the results of the prequeries;</p></li>
<li><p><strong>Post</strong>: Postqueries: these are performed next, and they can make use of the results of the prequeries and the postqueries, and are generally used to aggregate results;</p></li>
<li><p><strong>Form</strong>: Form queries: these are performed last, can make use of results obtained so far, usually do some further aggregation and  they make the forms.</p></li>
</ul>
</li>
<li><p><strong>Special1</strong>: Originally intended for future extensions. Currently in use for marking Star1 and Star2 language measures in TARSP (e..g T001, (Vr)WOnd+ occurs in Schlichting(2005) as (Vr)WOnd+** (with two stars), and therefore it has been marked as Star2. &#64;&#64;</p></li>
<li><p><strong>Special2</strong>: Originally intended for future extensions. Currently in use for filtering or allowing certain results depending on the function specified (see passfilter below), used to deal with certain interdependencies between prequery and corequery language measures.</p></li>
<li><p><strong>Comments</strong>: for any comments</p></li>
</ul>
<p>The language measures with  their properties are internally stored in a QueryDict: a dictionary with as key the QueryId, and as value a Query object</p>
<p>A special class <em>Method</em> has been defined in the module methods.py.</p>
<dl class="py class">
<dt class="sig sig-object py" id="methods.Method">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">methods.</span></span><span class="sig-name descname"><span class="pre">Method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">queries:</span> <span class="pre">~typing.Dict[str,</span> <span class="pre">~query.Query],</span> <span class="pre">item2idmap:</span> <span class="pre">~typing.Dict[~typing.Tuple[str,</span> <span class="pre">str],</span> <span class="pre">str],</span> <span class="pre">altcodes:</span> <span class="pre">~typing.Dict[~typing.Tuple[str,</span> <span class="pre">str],</span> <span class="pre">~typing.Tuple[str,</span> <span class="pre">str]],</span> <span class="pre">postquerylist:</span> <span class="pre">~typing.List[str],</span> <span class="pre">methodfilename:</span> <span class="pre">str,</span> <span class="pre">defaultfilter:</span> <span class="pre">~typing.Callable[[~query.Query,</span> <span class="pre">~typing.Dict[str,</span> <span class="pre">~typing.List[~typing.Tuple[str,</span> <span class="pre">int]]],</span> <span class="pre">~typing.Tuple[str,</span> <span class="pre">int]],</span> <span class="pre">bool]</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">allok&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/methods.html#Method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#methods.Method" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>The <em>Method</em> class has the following properties and methods:</p>
</div></blockquote>
<ul class="simple">
<li><p>name : MethodName: name of the method</p></li>
<li><p>queries : QueryDict = queries: a dictionary containing the queries (key is query id)</p></li>
<li><p>item2idmap : Item_Level2QIdDict. Dictionary that maps an (item, level) tuple to the QueryId</p></li>
<li><p>altcodes: AltCodeDict: dictionary with alternative codes and their mapping to the standard code</p></li>
<li><p>postquerylist : List[QId]: list of query id’s for queries that are post or form queries</p></li>
<li><p>methodfilename: FileName: filename of the file that contains the language measures</p></li>
<li><p>defaultfilter: ExactResultsFilter: name of the function that acts as the default filter to regulate interaction between prequeries and core queries. By default it has the value allok</p></li>
</ul>
</dd></dl>

<p>A method is read in by the read_method function in the readmethod.py module.</p>
<section id="queries">
<h2>Queries<a class="headerlink" href="#queries" title="Permalink to this heading">¶</a></h2>
<p>Queries take as input a syntactic structure for an utterance with utterance id <em>uttid</em>, implemented in sastadev as an lxml.etree Element.
They return a list of syntactic structures (the ones that match with the query), each an lxml.etree Element. Code around the application of a query turns this list of syntactic structures into a Counter with <em>(uttid, position)</em> as keys. The position is equal to the value of the <em>end</em> attribute of the leftmost word of the matching syntactic structure, or <em>0</em> if no match with a specific word can be indicated (in case of deleted or absent words). Such results are called <em>exact results</em> because they align the query to a particular word in the utterance. A Counter for a given query is stored in a dictionary with the query id as key and the Counter as value.</p>
<p>Actual comparisons with references to compute performance do not take the alignment into account, so the exact results are turned into (inexact) results which is a Counter with <em>uttid</em> as key. However, comparisons with references for development and debugging purposes (e.g. to create the “platinum check” files) do take the alignment into account.</p>
<p>Queries can be formulated in three different ways:</p>
<ul class="simple">
<li><p>Using pure Xpath</p></li>
<li><p>Using Xpath queries in combination with macros.</p></li>
<li><p>Python functions</p></li>
</ul>
<p>We will discuss each of them in a separate subsection.</p>
<section id="xpath">
<h3>Xpath<a class="headerlink" href="#xpath" title="Permalink to this heading">¶</a></h3>
<p>This is an example of an Xpath query, it is the query for the language measure T015 (BepBvZn) in TARSP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">node</span><span class="p">[</span><span class="nd">@cat</span><span class="o">=</span><span class="s2">&quot;np&quot;</span> <span class="ow">and</span>
        <span class="n">node</span><span class="p">[</span><span class="nd">@rel</span><span class="o">=</span><span class="s2">&quot;det&quot;</span> <span class="p">]</span> <span class="ow">and</span>
        <span class="n">node</span><span class="p">[</span><span class="nd">@rel</span><span class="o">=</span><span class="s2">&quot;mod&quot;</span> <span class="ow">and</span> <span class="nd">@pt</span><span class="o">=</span><span class="s2">&quot;adj&quot;</span><span class="p">]</span> <span class="ow">and</span>
        <span class="n">node</span><span class="p">[</span><span class="nd">@rel</span><span class="o">=</span><span class="s2">&quot;hd&quot;</span> <span class="ow">and</span> <span class="nd">@pt</span><span class="o">=</span><span class="s2">&quot;n&quot;</span><span class="p">]]</span>
</pre></div>
</div>
<p>It searches for a node (<em>node</em>) anywhere in the structure (<em>//</em>) where attribute (<em>&#64;</em>) <em>cat</em> (category) has the value (<em>=</em>)  <em>np</em> (“<em>np</em>”, noun phrase), and that contains (at least) three nodes:</p>
<ul class="simple">
<li><p>A node with attribute <em>rel</em> set to <em>det</em> (determiner)</p></li>
<li><p>A node with attribute <em>rel</em> set to <em>mod</em> (modifier) and attribute <em>pt</em> (part of speech) set to <em>adj</em> (adjective)</p></li>
<li><p>A node with attribute <em>rel</em> set to <em>hd</em> (head) and attribute <em>pt</em> set to <em>n</em> (noun)</p></li>
</ul>
<p>An Xpath query in SASTA  must start with <em>//</em> (it is necessary in the query and it distinguishes Xpath queries from python functions here). <em>//</em> means: search anywhere in the tree.</p>
<p>Note that inside the Sasta code each Xpath query gets “.” (meaning: from this point on) put in front of it. This is needed because in SASTA (like in GrETEL and in contrast to PaQu) there is only a single document for the whole treebank (but no documents for the individual utterances), and // would cause a search in the whole treebank, not only in the current utterance.</p>
</section>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this heading">¶</a></h3>
<p>Xpath is a very simple language, and many things that you want to express in it can only be expressed in a very cumbersome manner. Furthermore, certain parts of queries recur in multiple queries, and these should be defined only once to keep them compatible. For example, the definition of auxiliary verb occurs both in <em>Hww i</em> and in <em>HwwZ</em>, and that definition is pretty cumbersome, in part because Alpino does not itself have the notion of auxiliary verb, in part because of the limited expressivity of Xpath.</p>
<p>Xpath is so simple in part because it is usually used inside Xquery programs. Xquery is a full-fledged programming language with good expressivity. But in the GrETEL and SASTA context we do not have Xquery.
In order to avoid these problems we introduced macros, inspired by their use in the PaQu and GRETEL applications. A macro is nothing more than a string to abbreviate another string. A macro in SASTA (and in GrETEL, and in PaQu) is surrounded by % signs.</p>
<p>Macros are defined in text files inside a subfolder named macros of the code folder. Currently three macrofiles exist, but they should be reorganised into 4 files: one for general macros, and one for each method. These macro files are read in, parsed and stored for use in the macro expansion function every time Sasta is run, as defined in the module macros.py.</p>
<p>This is an example of a macro definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nonfinvc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;(@rel=&quot;vc&quot; and %nonfincat%) &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Here the macro <em>nonfinvc</em> is defined as (<em>=</em>) <em>(&#64;rel=”vc” and %nonfincat%)</em>.</p>
<p>As one can see this macrodefinition contains another macro, <em>nonfincat</em>, between % signs. That macro is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nonfincat</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;(@cat=&quot;inf&quot; or @cat=&quot;ppart&quot;)&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>where the definition only contains pieces of Xpath-code.</p>
<p>Inside SASTA an Xpath query is first expanded so that all macros have been replaced by pieces of Xpath code. Only then is the query launched.
The module that takes care of macros is the module macros.py:</p>
<span class="target" id="module-macros"></span><p>The macros module:</p>
<ul class="simple">
<li><p>reads in macro files</p></li>
<li><p>parses the macro files in the macros subfolder</p></li>
<li><p>stores them in a macro expansion dictionary macrodict with macro: expansion items as  key:value items</p></li>
<li><p>stores  macros generated by generatemacros.generatemacros in the macrodict dictionary</p></li>
<li><p>provides the function expandmacros of type <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">-&gt;</span> <span class="pre">str</span></code> to convert a string into a different string by expanding the macros in the input string</p></li>
</ul>
<p>The expansion function in this module  is called <em>expandmacros</em>. It takes as input a string and outputs a string with the macros expanded:</p>
<dl class="py function">
<dt class="sig sig-object py" id="macros.expandmacros">
<span class="sig-prename descclassname"><span class="pre">macros.</span></span><span class="sig-name descname"><span class="pre">expandmacros</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/macros.html#expandmacros"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#macros.expandmacros" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Expanding the following Xpath expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">node</span><span class="p">[</span><span class="o">%</span><span class="n">nonfinvc</span><span class="o">%</span><span class="p">]</span>
</pre></div>
</div>
<p>Results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">node</span><span class="p">[(</span><span class="nd">@rel</span><span class="o">=</span><span class="s2">&quot;vc&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="nd">@cat</span><span class="o">=</span><span class="s2">&quot;inf&quot;</span> <span class="ow">or</span> <span class="nd">@cat</span><span class="o">=</span><span class="s2">&quot;ppart&quot;</span><span class="p">))</span> <span class="p">]</span>
</pre></div>
</div>
<p>It is often desirable to test the correctness of the definition of a macro before it is included in the SASTA system. In the SASTA scripts there is a script <em>expandquery.py</em> which takes as input a query and puts the expansion in a
file called <em>expandedqueries.txt</em>. The expanded query can then be copied and pasted in GrETEL (which contains an Xpath parser and reports any errors) or any other Xpath validation programme, and can be tested in GrETEL.
This is the usage information of the expandquery.py script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Usage</span><span class="p">:</span> <span class="n">expandquery</span><span class="o">.</span><span class="n">py</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>
<span class="n">Options</span><span class="p">:</span>
  <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="o">--</span><span class="n">help</span>            <span class="n">show</span> <span class="n">this</span> <span class="n">help</span> <span class="n">message</span> <span class="ow">and</span> <span class="n">exit</span>
  <span class="o">-</span><span class="n">f</span> <span class="n">INFILENAME</span><span class="p">,</span> <span class="o">--</span><span class="n">file</span><span class="o">=</span><span class="n">INFILENAME</span>
                                                <span class="n">File</span> <span class="n">that</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">query</span> <span class="n">to</span> <span class="n">be</span> <span class="n">expanded</span>
  <span class="o">-</span><span class="n">q</span> <span class="n">QUERY</span><span class="p">,</span> <span class="o">--</span><span class="n">query</span><span class="o">=</span><span class="n">QUERY</span>
                                                <span class="n">query</span> <span class="k">as</span> <span class="n">a</span> <span class="n">string</span>
</pre></div>
</div>
<p>It is strongly recommended to have macro definitions begin and end with round brackets to avoid any operator priority issues. And generally, macros for conditions on nodes are often more reusable than macros for full nodes.
If one looks in the macro files, one quickly sees that many macros are defined in terms of multiple other macros, e.g. the definition of Tarsp_OndWBVC uses 6 macros in its definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Tarsp_OndWBVC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">(</span><span class="si">%d</span><span class="s2">eclarative</span><span class="si">% a</span><span class="s2">nd %Ond</span><span class="si">% a</span><span class="s2">nd  %Tarsp_W</span><span class="si">% a</span><span class="s2">nd %Tarsp_B_X</span><span class="si">% a</span><span class="s2">nd %Tarsp_VC_X</span><span class="si">% a</span><span class="s2">nd </span><span class="si">%r</span><span class="s2">ealcomplormodnodecount% = 3 )</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<section id="generation-of-macros">
<span id="generatemacros"></span><h4>Generation of macros<a class="headerlink" href="#generation-of-macros" title="Permalink to this heading">¶</a></h4>
<p>Macros make writing queries much simpler and makes it easier to maintain them. But in some cases macros are not enough, e.g. if a macro expansion is very large but built up in a regular way. One such case is dealt with by the module generatemacros.py:</p>
<span class="target" id="module-generatemacros"></span><p>The generatemacros module provides the function generatemacros of type None -&gt; Dict[str, str], which generates a macrodictionary
for systematically constructed macro definitions.</p>
<p>In particular, the module generatemacros.py generates macros for a list of pairs (verb, adposition),
e.g. (<em>slaan</em>, <em>op</em>) in which Alpino analyzes the adposition as the head of an prepositional complement (pc),
but where it should be considered the head of a modifier. These cases should also count as such if the
adposition is written together with <em>er</em>, <em>hier</em> or <em>daar</em> (e.g. <em>erop</em>, <em>hierop</em>, <em>daarop</em>),
which are considered unanalysable adverbs by Alpino.
So we need a macro which characterizes these exceptions for each (verb, adposition) pair and, for each pair,
for the combinations of the adposition with <em>er</em>, <em>hier</em> en <em>daar</em> when written together with the adposition.</p>
<p>The generatemacros function generates this macro on the basis of a list of  (verb, adposition) pairs contained in this module.
[These should probably better be moved to an exceptionslexicon module.]</p>
<p>Running the module standalone outputs the macrodefinitions to stdout</p>
</section>
</section>
</section>
<section id="python-functions">
<h2>Python functions<a class="headerlink" href="#python-functions" title="Permalink to this heading">¶</a></h2>
<p>In some cases formulating the query in Xpath is too cumbersome (even with macros). For such cases we can fall back on queries formulated in Python.</p>
<p>In the definition of the query one includes the name of the Python function, for example (from TARSP): <em>sziplus6</em>.
This function must be defined somewhere, of course. This can be done in any python module.</p>
<span class="target" id="module-external_functions"></span><p>The external_functions module creates the link between a function mentioned in the language measures and the python programme.
A function mentioned in a pre or core language measure takes as input a syntactic structure and
yields a list of nodes  as output.</p>
<p>A function mentioned in a post or form query takes as input an AllResults object and a syntactic strucure and
yields  a rersult of any type as output</p>
<p>If the function is defined in some other module, it must be imported here.
The name of the function must be added to one of the variables
<em>thetarspfunctions</em>, <em>thestapfunctions</em>, or <em>theastafunctions</em>, depending on the method that it belongs to.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Implementation of the methods</a><ul>
<li><a class="reference internal" href="#queries">Queries</a><ul>
<li><a class="reference internal" href="#xpath">Xpath</a></li>
<li><a class="reference internal" href="#macros">Macros</a><ul>
<li><a class="reference internal" href="#generation-of-macros">Generation of macros</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#python-functions">Python functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="alpinoparser.html"
                          title="previous chapter">Alpino parser</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="Tarsp.html"
                          title="next chapter">TARSP Language Measures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/methodimplementation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Tarsp.html" title="TARSP Language Measures"
             >next</a> |</li>
        <li class="right" >
          <a href="alpinoparser.html" title="Alpino parser"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SASTA  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Implementation of the methods</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Jan Odijk, Jelte van Boheemen, Martin Kroon.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>