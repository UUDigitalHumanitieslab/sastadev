
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>correcttreebank &#8212; SASTA  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SASTA  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">correcttreebank</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for correcttreebank</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">lxml</span> <span class="k">import</span> <span class="n">etree</span>

<span class="kn">from</span> <span class="nn">basicreplacements</span> <span class="k">import</span> <span class="n">basicreplacements</span>
<span class="kn">from</span> <span class="nn">corrector</span> <span class="k">import</span> <span class="n">Correction</span><span class="p">,</span> <span class="n">getcorrections</span><span class="p">,</span> <span class="n">mkuttwithskips</span><span class="p">,</span> <span class="n">disambiguationdict</span>
<span class="kn">from</span> <span class="nn">lexicon</span> <span class="k">import</span> <span class="n">de</span><span class="p">,</span> <span class="n">dets</span><span class="p">,</span> <span class="n">known_word</span>
<span class="kn">from</span> <span class="nn">metadata</span> <span class="k">import</span> <span class="p">(</span><span class="n">Meta</span><span class="p">,</span> <span class="n">bpl_delete</span><span class="p">,</span> <span class="n">bpl_indeze</span><span class="p">,</span> <span class="n">bpl_node</span><span class="p">,</span> <span class="n">bpl_none</span><span class="p">,</span>
                      <span class="n">bpl_word</span><span class="p">,</span> <span class="n">bpl_wordlemma</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sastatok</span> <span class="k">import</span> <span class="n">sasta_tokenize</span>
<span class="kn">from</span> <span class="nn">sastatoken</span> <span class="k">import</span> <span class="n">tokenlist2stringlist</span><span class="p">,</span> <span class="n">Token</span>
<span class="kn">from</span> <span class="nn">sva</span> <span class="k">import</span> <span class="n">phicompatible</span>
<span class="kn">from</span> <span class="nn">targets</span> <span class="k">import</span> <span class="n">get_mustbedone</span>
<span class="kn">from</span> <span class="nn">treebankfunctions</span> <span class="k">import</span> <span class="p">(</span><span class="n">adaptsentence</span><span class="p">,</span> <span class="n">add_metadata</span><span class="p">,</span> <span class="n">countav</span><span class="p">,</span>
                               <span class="n">deletewordnodes</span><span class="p">,</span> <span class="n">find1</span><span class="p">,</span> <span class="n">getattval</span><span class="p">,</span> <span class="n">getbeginend</span><span class="p">,</span>
                               <span class="n">getcompoundcount</span><span class="p">,</span> <span class="n">getnodeyield</span><span class="p">,</span> <span class="n">getsentid</span><span class="p">,</span>
                               <span class="n">gettokposlist</span><span class="p">,</span> <span class="n">getyield</span><span class="p">,</span> <span class="n">myfind</span><span class="p">,</span> <span class="n">showflatxml</span><span class="p">,</span>
                               <span class="n">simpleshow</span><span class="p">,</span> <span class="n">transplant_node</span><span class="p">,</span> <span class="n">showtree</span><span class="p">,</span> <span class="n">treeinflate</span><span class="p">,</span> <span class="n">fatparse</span><span class="p">,</span> <span class="n">treewithtokenpos</span><span class="p">,</span>
                               <span class="n">updatetokenpos</span><span class="p">,</span> <span class="n">getuttid</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="k">import</span> <span class="n">PARSE_FUNC</span><span class="p">,</span> <span class="n">SDLOGGER</span>
<span class="kn">from</span> <span class="nn">metadata</span> <span class="k">import</span> <span class="n">insertion</span>
<span class="kn">from</span> <span class="nn">sastatoken</span> <span class="k">import</span> <span class="n">inflate</span><span class="p">,</span> <span class="n">deflate</span><span class="p">,</span> <span class="n">tokeninflate</span><span class="p">,</span> <span class="n">insertinflate</span>
<span class="kn">from</span> <span class="nn">CHAT_Annotation</span> <span class="k">import</span> <span class="n">omittedword</span>
<span class="kn">from</span> <span class="nn">cleanCHILDEStokens</span> <span class="k">import</span> <span class="n">cleantext</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">sastatypes</span> <span class="k">import</span> <span class="n">AltId</span><span class="p">,</span> <span class="n">CorrectionMode</span><span class="p">,</span> <span class="n">ErrorDict</span><span class="p">,</span> <span class="n">UttId</span><span class="p">,</span> <span class="n">MetaElement</span><span class="p">,</span> <span class="n">MethodName</span><span class="p">,</span> <span class="n">Penalty</span><span class="p">,</span> <span class="n">Position</span><span class="p">,</span> <span class="n">PositionStr</span><span class="p">,</span> \
    <span class="n">SynTree</span><span class="p">,</span> <span class="n">Targets</span><span class="p">,</span> <span class="n">Treebank</span>

<span class="n">ampersand</span> <span class="o">=</span> <span class="s1">&#39;&amp;&#39;</span>

<span class="n">corr0</span><span class="p">,</span> <span class="n">corr1</span><span class="p">,</span> <span class="n">corrn</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span>
<span class="n">validcorroptions</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr0</span><span class="p">,</span> <span class="n">corr1</span><span class="p">,</span> <span class="n">corrn</span><span class="p">]</span>

<span class="n">space</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>
<span class="n">origuttxpath</span> <span class="o">=</span> <span class="s1">&#39;.//meta[@name=&quot;origutt&quot;]/@value&#39;</span>
<span class="n">uttidxpath</span> <span class="o">=</span> <span class="s1">&#39;.//meta[@name=&quot;uttid&quot;]/@value&#39;</span>
<span class="n">metadataxpath</span> <span class="o">=</span> <span class="s1">&#39;.//metadata&#39;</span>
<span class="n">dezeAVntemplate</span> <span class="o">=</span> <span class="s1">&#39;&lt;node begin=&quot;</span><span class="si">{begin}</span><span class="s1">&quot; buiging=&quot;met-e&quot; end=&quot;</span><span class="si">{end}</span><span class="s1">&quot; frame=&quot;determiner(de,nwh,nmod,pro,nparg)&quot; &#39;</span> \
                  <span class="s1">&#39;id=&quot;</span><span class="si">{id}</span><span class="s1">&quot; infl=&quot;de&quot; lcat=&quot;np&quot; lemma=&quot;deze&quot; naamval=&quot;stan&quot; npagr=&quot;rest&quot; pdtype=&quot;det&quot; pos=&quot;det&quot; &#39;</span> \
                  <span class="s1">&#39;positie=&quot;nom&quot; postag=&quot;VNW(aanw,det,stan,nom,met-e,rest)&quot; pt=&quot;vnw&quot; rel=&quot;obj1&quot; root=&quot;deze&quot; &#39;</span> \
                  <span class="s1">&#39;sense=&quot;deze&quot; vwtype=&quot;aanw&quot; wh=&quot;nwh&quot; word=&quot;deze&quot;/&gt;&#39;</span>

<span class="n">contextualproperties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;positie&#39;</span><span class="p">]</span>

<span class="n">errorwbheader</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Sample&#39;</span><span class="p">,</span> <span class="s1">&#39;User1&#39;</span><span class="p">,</span> <span class="s1">&#39;User2&#39;</span><span class="p">,</span> <span class="s1">&#39;User3&#39;</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">,</span> <span class="s1">&#39;Uttid&#39;</span><span class="p">,</span> <span class="s1">&#39;Origutt&#39;</span><span class="p">,</span> <span class="s1">&#39;Origsent&#39;</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">[</span><span class="s1">&#39;altid&#39;</span><span class="p">,</span> <span class="s1">&#39;altsent&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;penalty&#39;</span><span class="p">,</span> <span class="s1">&#39;dpcount&#39;</span><span class="p">,</span> <span class="s1">&#39;dhyphencount&#39;</span><span class="p">,</span> <span class="s1">&#39;dimcount&#39;</span><span class="p">,</span> <span class="s1">&#39;compcount&#39;</span><span class="p">,</span> <span class="s1">&#39;supcount&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;compoundcount&#39;</span><span class="p">,</span> <span class="s1">&#39;unknownwordcount&#39;</span><span class="p">,</span> <span class="s1">&#39;sucount&#39;</span><span class="p">,</span> <span class="s1">&#39;svaokcount&#39;</span><span class="p">,</span> <span class="s1">&#39;deplusneutcount&#39;</span><span class="p">,</span> <span class="s1">&#39;goodcatcount&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;hyphencount&#39;</span><span class="p">,</span> <span class="s1">&#39;basicreplaceecount&#39;</span><span class="p">]</span>

<span class="n">ParsedCorrection</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Meta</span><span class="p">]]</span>
<span class="n">Tuple15int</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Alternative</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stree</span><span class="p">,</span> <span class="n">altid</span><span class="p">,</span> <span class="n">altsent</span><span class="p">,</span> <span class="n">penalty</span><span class="p">,</span> <span class="n">dpcount</span><span class="p">,</span> <span class="n">dhyphencount</span><span class="p">,</span> <span class="n">dimcount</span><span class="p">,</span>
                 <span class="n">compcount</span><span class="p">,</span> <span class="n">supcount</span><span class="p">,</span> <span class="n">compoundcount</span><span class="p">,</span> <span class="n">unknownwordcount</span><span class="p">,</span> <span class="n">sucount</span><span class="p">,</span> <span class="n">svaok</span><span class="p">,</span> <span class="n">deplusneutcount</span><span class="p">,</span> <span class="n">goodcatcount</span><span class="p">,</span>
                 <span class="n">hyphencount</span><span class="p">,</span> <span class="n">basicreplaceecount</span><span class="p">,</span> <span class="n">ambigcount</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span> <span class="o">=</span> <span class="n">stree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altid</span><span class="p">:</span> <span class="n">AltId</span> <span class="o">=</span> <span class="n">altid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altsent</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">altsent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">:</span> <span class="n">Penalty</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">penalty</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dpcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dpcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dhyphencount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dhyphencount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">compcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">supcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compoundcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">compoundcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unknownwordcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">unknownwordcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sucount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sucount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">svaok</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">svaok</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deplusneutcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">deplusneutcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goodcatcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">goodcatcount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyphencount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hyphencount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basicreplaceecount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">basicreplaceecount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ambigcount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ambigcount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">alt2row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uttid</span><span class="p">:</span> <span class="n">UttId</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">user1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">user2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">user3</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="n">bestaltids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AltId</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
                <span class="n">selected</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AltId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">origsent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BEST&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">altid</span> <span class="ow">in</span> <span class="n">bestaltids</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">altid</span> <span class="o">==</span> <span class="n">selected</span><span class="p">:</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;SELECTED&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;NOTSELECTED&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">altsent</span> <span class="o">==</span> <span class="n">origsent</span><span class="p">:</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;IDENTICAL&#39;</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">ampersand</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="n">part4</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">altid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">altsent</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dpcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dhyphencount</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">dimcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compoundcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknownwordcount</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">sucount</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">svaok</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deplusneutcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goodcatcount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyphencount</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">basicreplaceecount</span><span class="p">]))</span>
        <span class="n">therow</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="p">,</span> <span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">]</span> <span class="o">+</span> \
                       <span class="p">[</span><span class="s1">&#39;Alternative&#39;</span><span class="p">,</span> <span class="n">uttid</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">part4</span>

        <span class="k">return</span> <span class="n">therow</span>

    <span class="k">def</span> <span class="nf">betterscorethan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># looping reference to Alternative needed</span>
        <span class="n">score</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;alt&#39;</span><span class="p">,</span> <span class="n">alt</span><span class="p">)]:</span>
            <span class="n">score</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">scorefunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">score</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">equalscoreas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;alt&#39;</span><span class="p">,</span> <span class="n">alt</span><span class="p">)]:</span>
            <span class="n">score</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">scorefunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">score</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">Original</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uttid</span><span class="p">,</span> <span class="n">stree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uttid</span><span class="p">:</span> <span class="n">UttId</span> <span class="o">=</span> <span class="n">uttid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span> <span class="o">=</span> <span class="n">stree</span>

    <span class="k">def</span> <span class="nf">original2row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">user1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">user2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">user3</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">origutt</span> <span class="o">=</span> <span class="n">getorigutt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stree</span><span class="p">)</span>
        <span class="n">origtokenlist</span> <span class="o">=</span> <span class="n">getyield</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stree</span><span class="p">)</span>
        <span class="n">origsent</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">origtokenlist</span><span class="p">)</span>
        <span class="n">theuttid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uttid</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uttid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;??&#39;</span>
        <span class="n">therow</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="p">,</span> <span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">]</span> <span class="o">+</span> \
                 <span class="p">[</span><span class="s1">&#39;Original&#39;</span><span class="p">,</span> <span class="n">theuttid</span><span class="p">,</span> <span class="n">origutt</span><span class="p">,</span> <span class="n">origsent</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">therow</span>


<span class="k">class</span> <span class="nc">OrigandAlts</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">alts</span><span class="p">,</span> <span class="n">selected</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig</span> <span class="o">=</span> <span class="n">orig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">AltId</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">]</span> <span class="o">=</span> <span class="n">alts</span>  <span class="c1"># a dictionary with altid as key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected</span><span class="p">:</span> <span class="n">AltId</span> <span class="o">=</span> <span class="n">selected</span>

    <span class="k">def</span> <span class="nf">OrigandAlts2rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">user1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">user2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">user3</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">origrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="o">.</span><span class="n">original2row</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">)</span>
        <span class="n">origsent</span> <span class="o">=</span> <span class="n">origrow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bestaltids</span> <span class="o">=</span> <span class="n">getbestaltids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alts</span><span class="p">)</span>
        <span class="n">altsrows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alts</span><span class="p">[</span><span class="n">altid</span><span class="p">]</span><span class="o">.</span><span class="n">alt2row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="o">.</span><span class="n">uttid</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">,</span> <span class="n">bestaltids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected</span><span class="p">,</span> <span class="n">origsent</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">altid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alts</span><span class="p">]</span>
        <span class="n">laltsrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">altsrows</span><span class="p">)</span>
        <span class="n">selectedrow</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="p">,</span> <span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">,</span> <span class="n">user3</span><span class="p">]</span> <span class="o">+</span> \
                      <span class="p">[</span><span class="s1">&#39;Selected&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="o">.</span><span class="n">uttid</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected</span><span class="p">]</span><span class="o">.</span><span class="n">altsent</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">laltsrows</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">origrow</span><span class="p">]</span> <span class="o">+</span> <span class="n">altsrows</span> <span class="o">+</span> <span class="p">[</span><span class="n">selectedrow</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">rows</span>


<span class="k">def</span> <span class="nf">get_origandparsedas</span><span class="p">(</span><span class="n">metadatalist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MetaElement</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="n">parsed_as</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">origutt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">metadatalist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">parsed_as</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">origutt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;parsed_as&#39;</span><span class="p">:</span>
                <span class="n">parsed_as</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;origutt&#39;</span><span class="p">:</span>
                <span class="n">origutt</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">origutt</span><span class="p">,</span> <span class="n">parsed_as</span>


<span class="k">def</span> <span class="nf">mkmetarecord</span><span class="p">(</span><span class="n">meta</span><span class="p">:</span> <span class="n">MetaElement</span><span class="p">,</span> <span class="n">origutt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsed_as</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[]</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;xmeta&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;CHAT&#39;</span><span class="p">,</span> <span class="s1">&#39;SASTA&#39;</span><span class="p">]:</span>
            <span class="n">newmetarecord</span> <span class="o">=</span> <span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">],</span>
                             <span class="n">meta</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;subcat&#39;</span><span class="p">],</span> <span class="n">origutt</span><span class="p">,</span> <span class="n">parsed_as</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">newmetarecord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">updateerrordict</span><span class="p">(</span><span class="n">errordict</span><span class="p">:</span> <span class="n">ErrorDict</span><span class="p">,</span> <span class="n">uttid</span><span class="p">:</span> <span class="n">UttId</span><span class="p">,</span> <span class="n">oldtree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">newtree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ErrorDict</span><span class="p">:</span>
    <span class="n">metadatalist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MetaElement</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">metadataxpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metadatalist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origutt</span><span class="p">,</span> <span class="n">parsed_as</span> <span class="o">=</span> <span class="n">get_origandparsedas</span><span class="p">(</span><span class="n">metadatalist</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">metadatalist</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">newmetarecord</span> <span class="o">=</span> <span class="n">mkmetarecord</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">origutt</span><span class="p">,</span> <span class="n">parsed_as</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">newmetarecord</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">errordict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">uttid</span><span class="p">]</span> <span class="o">+</span> <span class="n">newmetarecord</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">errordict</span>


<div class="viewcode-block" id="correcttreebank"><a class="viewcode-back" href="../deviantlanguage.html#correcttreebank.correcttreebank">[docs]</a><span class="k">def</span> <span class="nf">correcttreebank</span><span class="p">(</span><span class="n">treebank</span><span class="p">:</span> <span class="n">Treebank</span><span class="p">,</span> <span class="n">targets</span><span class="p">:</span> <span class="n">Targets</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">MethodName</span><span class="p">,</span> <span class="n">corr</span><span class="p">:</span> <span class="n">CorrectionMode</span> <span class="o">=</span> <span class="n">corrn</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Treebank</span><span class="p">,</span> <span class="n">ErrorDict</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">OrigandAlts</span><span class="p">]]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The function *correcttreebank* takes as input:</span>

<span class="sd">    * treebank: the treebank of the sample, parsed as is.</span>
<span class="sd">    * targets: a specification of the utterances that have to be analysed</span>
<span class="sd">    * method: the method to be used. Some corrections are method-specific</span>
<span class="sd">    * corr: to indicate how the corrections should be done: no corrections at all, all corrections but the last one (usually the one with most adaptations) is selected; all  corrections but the best one according to the evaluation  criterion is selected.</span>


<span class="sd">    It returns a triple consisting of</span>

<span class="sd">    * the corrected treebank</span>
<span class="sd">    * an error dictionary: a list of errors detected and how they have corrected</span>
<span class="sd">    * a list of all original utterances and all alternatives that have been considered</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">allorandalts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">OrigandAlts</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">errordict</span><span class="p">:</span> <span class="n">ErrorDict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">corr</span> <span class="o">==</span> <span class="n">corr0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">treebank</span><span class="p">,</span> <span class="n">errordict</span><span class="p">,</span> <span class="n">allorandalts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">newtreebank</span><span class="p">:</span> <span class="n">Treebank</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;treebank&#39;</span><span class="p">)</span>
        <span class="c1"># errorlogrows = []</span>
        <span class="k">for</span> <span class="n">stree</span> <span class="ow">in</span> <span class="n">treebank</span><span class="p">:</span>
            <span class="n">uttid</span> <span class="o">=</span> <span class="n">getuttid</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
            <span class="c1"># print(uttid)</span>
            <span class="n">mustbedone</span> <span class="o">=</span> <span class="n">get_mustbedone</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mustbedone</span><span class="p">:</span>
                <span class="c1"># to implement</span>
                <span class="n">newstree</span><span class="p">,</span> <span class="n">orandalts</span> <span class="o">=</span> <span class="n">correct_stree</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newstree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">errordict</span> <span class="o">=</span> <span class="n">updateerrordict</span><span class="p">(</span><span class="n">errordict</span><span class="p">,</span> <span class="n">uttid</span><span class="p">,</span> <span class="n">stree</span><span class="p">,</span> <span class="n">newstree</span><span class="p">)</span>
                    <span class="n">newtreebank</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newstree</span><span class="p">)</span>
                    <span class="n">allorandalts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orandalts</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newtreebank</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newtreebank</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newtreebank</span><span class="p">,</span> <span class="n">errordict</span><span class="p">,</span> <span class="n">allorandalts</span></div>


<span class="k">def</span> <span class="nf">contextualise</span><span class="p">(</span><span class="n">node1</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">node2</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SynTree</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    copies the contextually determined properties of node2 to node1</span>
<span class="sd">    :param node1:</span>
<span class="sd">    :param node2:</span>
<span class="sd">    :return: adapted version of node1</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">newnode</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">contextualproperties</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">node2</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">newnode</span>


<span class="k">def</span> <span class="nf">updatemetadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Meta</span><span class="p">],</span> <span class="n">tokenposdict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Position</span><span class="p">,</span> <span class="n">Position</span><span class="p">]):</span>
    <span class="n">begintokenposdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tokenposdict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">newmetadata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="n">newmeta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>
        <span class="n">newmeta</span><span class="o">.</span><span class="n">annotationposlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">begintokenposdict</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">begintokenposdict</span> <span class="k">else</span> <span class="n">insertinflate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span>
                                     <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">annotationposlist</span><span class="p">]</span>
        <span class="n">newmeta</span><span class="o">.</span><span class="n">annotatedposlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">begintokenposdict</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">begintokenposdict</span> <span class="k">else</span> <span class="n">insertinflate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span>
                                    <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">annotatedposlist</span><span class="p">]</span>
        <span class="n">newmetadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newmeta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newmetadata</span>


<span class="k">def</span> <span class="nf">updatetokenposmd</span><span class="p">(</span><span class="n">intree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Meta</span><span class="p">],</span> <span class="n">tokenposdict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Position</span><span class="p">,</span> <span class="n">Position</span><span class="p">]):</span>
    <span class="n">resulttree</span> <span class="o">=</span> <span class="n">updatetokenpos</span><span class="p">(</span><span class="n">intree</span><span class="p">,</span> <span class="n">tokenposdict</span><span class="p">)</span>
    <span class="n">newmetadata</span> <span class="o">=</span> <span class="n">updatemetadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">tokenposdict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resulttree</span><span class="p">,</span> <span class="n">newmetadata</span>


<span class="k">def</span> <span class="nf">findskippednodes</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SynTree</span><span class="p">]:</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;findskippednodes:stree:&#39;</span><span class="p">)</span>
    <span class="n">topnode</span> <span class="o">=</span> <span class="n">find1</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="s1">&#39;.//node[@cat=&quot;top&quot;]&#39;</span><span class="p">)</span>
    <span class="c1"># tokenposdict =  {i+1:tokenlist[i].pos+1 for i in range(len(tokenlist))}</span>
    <span class="n">tokenposset</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokenlist</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">skip</span><span class="p">}</span>
    <span class="n">resultlist</span> <span class="o">=</span> <span class="n">findskippednodes2</span><span class="p">(</span><span class="n">topnode</span><span class="p">,</span> <span class="n">tokenposset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultlist</span>


<span class="k">def</span> <span class="nf">findskippednodes2</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">tokenposset</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Position</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SynTree</span><span class="p">]:</span>
    <span class="n">resultlist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SynTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">stree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">resultlist</span>
    <span class="k">if</span> <span class="s1">&#39;pt&#39;</span> <span class="ow">in</span> <span class="n">stree</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">or</span> <span class="s1">&#39;pos&#39;</span> <span class="ow">in</span> <span class="n">stree</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">stree</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tokenposset</span><span class="p">:</span>
            <span class="n">resultlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s1">&#39;cat&#39;</span> <span class="ow">in</span> <span class="n">stree</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">stree</span><span class="p">:</span>
            <span class="n">resultlist</span> <span class="o">+=</span> <span class="n">findskippednodes2</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tokenposset</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">resultlist</span>


<span class="k">def</span> <span class="nf">insertskips</span><span class="p">(</span><span class="n">newstree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">],</span> <span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SynTree</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    :param newstree: the corrected tree, with skipped elements absent</span>
<span class="sd">    :param tokenposlist: list of all tokens with skips marked</span>
<span class="sd">    :param stree: original stree with parses of the skipped elements</span>
<span class="sd">    :return: adapted tree, with the skipped elements inserted (node from the original stree as -- under top, begin/ends updates</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">newstree</span><span class="p">,</span> <span class="s1">&#39;newstree:&#39;</span><span class="p">)</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="s1">&#39;stree&#39;</span><span class="p">)</span>
    <span class="n">reducedtokenlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokenlist</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">skip</span><span class="p">]</span>
    <span class="n">resulttree</span> <span class="o">=</span> <span class="n">treewithtokenpos</span><span class="p">(</span><span class="n">newstree</span><span class="p">,</span> <span class="n">reducedtokenlist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;resulttree:&#39;</span><span class="p">)</span>
    <span class="n">streetokenlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokenlist</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">subpos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">stree</span> <span class="o">=</span> <span class="n">treewithtokenpos</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">streetokenlist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;stree with tokenpos:&#39;</span><span class="p">)</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># tokenpostree = deepcopy(stree)</span>
    <span class="c1"># update begin/ends</span>
    <span class="c1"># next not needed anymore</span>
    <span class="c1"># tokenposdict = {i + 1: reducedtokenlist[i].pos + 1 for i in range(len(reducedtokenlist))}</span>
    <span class="c1"># showtree(resulttree, text=&#39;in: &#39;)</span>
    <span class="c1"># resulttree, newmetadata = updatetokenposmd(resulttree, metadata, tokenposdict)</span>
    <span class="c1"># showtree(resulttree, text=&#39;out:&#39;)</span>
    <span class="c1"># tokenpostree = updatetokenpos(tokenpostree, tokenposdict)</span>
    <span class="c1"># if debug:</span>
    <span class="c1"># print(&#39;\nstree:&#39;)</span>
    <span class="c1"># etree.dump(stree)</span>
    <span class="c1"># # print(&#39;\ntokenpostree:&#39;)</span>
    <span class="c1"># # etree.dump(tokenpostree)</span>
    <span class="c1"># print(&#39;\nresulttree:&#39;)</span>
    <span class="c1"># etree.dump(resulttree)</span>

    <span class="c1"># insert skipped elements</span>
    <span class="n">nodestoinsert</span> <span class="o">=</span> <span class="n">findskippednodes</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">)</span>
    <span class="n">nodestoinsertcopies</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodestoinsert</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;insertskips: stree:&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;insertskips: resulttree:&#39;</span><span class="p">)</span>
    <span class="n">topnode</span> <span class="o">=</span> <span class="n">find1</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="s1">&#39;.//node[@cat=&quot;top&quot;] &#39;</span><span class="p">)</span>
    <span class="n">topchildren</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">topnode</span><span class="p">]</span>
    <span class="n">allchildren</span> <span class="o">=</span> <span class="n">nodestoinsertcopies</span> <span class="o">+</span> <span class="n">topchildren</span>
    <span class="n">sortedchildren</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">allchildren</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;insertskips: resulttree:&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">topnode</span><span class="p">:</span>
        <span class="n">topnode</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;insertskips: resulttree:&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sortedchildren</span><span class="p">:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>  <span class="c1"># these are now extragrammatical with relation --</span>
        <span class="n">topnode</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;insertskips: resulttree:&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">getbeginend</span><span class="p">(</span><span class="n">sortedchildren</span><span class="p">)</span>
    <span class="n">topnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;begin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">topnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;insertskips: resulttree:&#39;</span><span class="p">)</span>

    <span class="n">sentlist</span> <span class="o">=</span> <span class="n">getyield</span><span class="p">(</span><span class="n">resulttree</span><span class="p">)</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentlist</span><span class="p">)</span>
    <span class="n">sentnode</span> <span class="o">=</span> <span class="n">find1</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="s1">&#39;sentence&#39;</span><span class="p">)</span>
    <span class="n">sentnode</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">sent</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">resulttree</span><span class="p">,</span> <span class="s1">&#39;result of insertskips&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resulttree</span>


<span class="k">def</span> <span class="nf">getomittedwordbegins</span><span class="p">(</span><span class="n">metalist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Meta</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Position</span><span class="p">]:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">metalist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">omittedword</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">annotatedposlist</span>
    <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="correct_stree"><a class="viewcode-back" href="../deviantlanguage.html#correcttreebank.correct_stree">[docs]</a><span class="k">def</span> <span class="nf">correct_stree</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">MethodName</span><span class="p">,</span> <span class="n">corr</span><span class="p">:</span> <span class="n">CorrectionMode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">SynTree</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">OrigandAlts</span><span class="p">]]:</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">     The function *correct_stree* takes as input:</span>

<span class="sd">    * stree: input syntactic structure</span>
<span class="sd">    * method:  MethodName (tarsp, asta, stap)</span>
<span class="sd">    * corr: CorrectionMode (corr0, corr1, corrn)</span>

<span class="sd">    and returns a tuple consisting of:</span>

<span class="sd">    * the corrected syntactic structure</span>
<span class="sd">    * optionally a specification of the original utterance and all alternatives  considered</span>

<span class="sd">    The following steps are carried out:</span>

<span class="sd">    1. The original utterance, with all CHAT-annotations, is cleaned using the function *cleantext* from the module</span>
<span class="sd">    *cleanCHILDEStokens*. This is necessary to generate the metadata for the CHAT-annotations, but it can be</span>
<span class="sd">    discarded when the original parses use the same *cleantext* function. Currently that is not possible yet because</span>
<span class="sd">    the original parsing is done via GrETEL modules, which cannot handle complex metadata (xmeta). The result of</span>
<span class="sd">    this operation is a list of tokens of type *Token* as defined in the module *sastatoken*. @@add ref@@</span>

<span class="sd">    2. Alpino parses are inflated to be able to deal easily with insertions and deletions. @@add ref@@</span>

<span class="sd">    3. The corrections are obtained by calling the function *getcorrections* from the module *corrector*</span>

<span class="sd">    4. The corrections may have tokens that are marked with skip=True, in which case they should not be included in the</span>
<span class="sd">    corrected utterance, so  a corrected utterance with these words left out is created.</span>

<span class="sd">    5. Each corrected utterance  is parsed, resulting in an inflated syntactic structure.</span>

<span class="sd">    6. Words that were left out are now introduced into the syntactic structure, in such a way that they have no</span>
<span class="sd">    grammatical relations with other words.</span>

<span class="sd">    7. The best alternative is selected from among the original utterance and the generated corrected utterances by</span>
<span class="sd">    the function *selectcorrection* from the module *correcttreebank*.</span>

<span class="sd">    8. The original words and sometimes their properties are now substituted for the corrections. The exact nature of</span>
<span class="sd">    the replacement is determined by the value of the *backplacement* attribute of the metadata. Expansions are not</span>
<span class="sd">    replaced yet, because they must be replaced only after the queries have been executed. Nodes for words that have</span>
<span class="sd">    to be deleted are collected, but the actual deletion only takes place in the next step.</span>

<span class="sd">    9. Words that were marked to be deleted are now all deleted, by the function *deletewordnodes* of the module</span>
<span class="sd">    *treebankfunction*.</span>

<span class="sd">    10. The metadata are updated and added to the syntactic structure.</span>

<span class="sd">    11. During the whole process the mapping between the nodes for words in the original syntactic structure and the</span>
<span class="sd">    nodes for words in the syntactic structure for the corrected utterance must be perfect. A check is performed</span>
<span class="sd">    to determine whether this is the case.</span>

<span class="sd">    12. Finally, the corrected syntactic structure and the specification of the original utterance and all alternatives</span>
<span class="sd">    considered is returned.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># debug = True</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;1:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;: &#39;</span><span class="p">)</span>
        <span class="n">simpleshow</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">showflatxml</span><span class="p">(</span><span class="n">stree</span><span class="p">))</span>

    <span class="n">allmetadata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># orandalts = []</span>

    <span class="c1"># uttid:</span>
    <span class="n">uttid</span> <span class="o">=</span> <span class="n">getuttid</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="n">sentid</span> <span class="o">=</span> <span class="n">getsentid</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>

    <span class="c1"># get the original utterance</span>

    <span class="n">origutt</span> <span class="o">=</span> <span class="n">getorigutt</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">origutt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Missing origutt in utterance </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="p">))</span>
        <span class="n">origutt</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">getyield</span><span class="p">(</span><span class="n">stree</span><span class="p">))</span>
        <span class="c1"># return stree, orandalts</span>
    <span class="c1"># list of token positions</span>

    <span class="c1"># get the original metadata; these will be added later to the tree of each correction</span>
    <span class="n">metadatalist</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="n">metadataxpath</span><span class="p">)</span>
    <span class="n">lmetadatalist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadatalist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lmetadatalist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Missing metadata in utterance </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">lmetadatalist</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Multiple metadata (</span><span class="si">{}</span><span class="s1">) in utterance </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lmetadatalist</span><span class="p">,</span> <span class="n">uttid</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origmetadata</span> <span class="o">=</span> <span class="n">metadatalist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># allmetadata += origmetadata</span>
    <span class="c1"># clean in the tokenized manner</span>

    <span class="n">cleanutttokens</span><span class="p">,</span> <span class="n">chatmetadata</span> <span class="o">=</span> <span class="n">cleantext</span><span class="p">(</span><span class="n">origutt</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tokenoutput</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">allmetadata</span> <span class="o">+=</span> <span class="n">chatmetadata</span>
    <span class="c1"># cleanutttokens = sasta_tokenize(cleanutt)</span>
    <span class="n">cleanuttwordlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">word</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cleanutttokens</span><span class="p">]</span>
    <span class="n">cleanutt</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cleanuttwordlist</span><span class="p">)</span>

    <span class="c1"># get corrections, given the inflated stree</span>
    <span class="c1"># inflate the tree</span>
    <span class="n">fatstree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="n">treeinflate</span><span class="p">(</span><span class="n">fatstree</span><span class="p">)</span>
    <span class="c1"># adapt the begins and ends  in the tree based on the token positions</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;fatstree voor:&#39;</span><span class="p">)</span>
    <span class="n">tokenlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cleanutttokens</span><span class="p">]</span>
    <span class="n">fatstree</span> <span class="o">=</span> <span class="n">treewithtokenpos</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;fatstree na:&#39;</span><span class="p">)</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># (fatstree, text=&#39;fattened tree:&#39;)</span>

    <span class="n">ctmds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Correction</span><span class="p">]</span> <span class="o">=</span> <span class="n">getcorrections</span><span class="p">(</span><span class="n">cleanutttokens</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fatstree</span><span class="p">)</span>

    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;2:&#39;</span><span class="p">)</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">ptmds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">correctiontokenlist</span><span class="p">,</span> <span class="n">cwmdmetadata</span> <span class="ow">in</span> <span class="n">ctmds</span><span class="p">:</span>
        <span class="n">cwmdmetadata</span> <span class="o">+=</span> <span class="n">allmetadata</span>
        <span class="n">correctionwordlist</span> <span class="o">=</span> <span class="n">tokenlist2stringlist</span><span class="p">(</span><span class="n">correctiontokenlist</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># parse the corrections</span>
        <span class="k">if</span> <span class="n">correctionwordlist</span> <span class="o">!=</span> <span class="n">cleanuttwordlist</span> <span class="ow">and</span> <span class="n">correctionwordlist</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">correction</span><span class="p">,</span> <span class="n">tokenposlist</span> <span class="o">=</span> <span class="n">mkuttwithskips</span><span class="p">(</span><span class="n">correctiontokenlist</span><span class="p">)</span>
            <span class="n">cwmdmetadata</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Meta</span><span class="p">(</span><span class="s1">&#39;parsed_as&#39;</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Correction&#39;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;SASTA&#39;</span><span class="p">)]</span>
            <span class="n">reducedcorrectiontokenlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">token</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">correctiontokenlist</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="o">.</span><span class="n">skip</span><span class="p">]</span>
            <span class="n">fatnewstree</span> <span class="o">=</span> <span class="n">fatparse</span><span class="p">(</span><span class="n">correction</span><span class="p">,</span> <span class="n">reducedcorrectiontokenlist</span><span class="p">)</span>
            <span class="n">debugb</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">debugb</span><span class="p">:</span>
                <span class="n">showtree</span><span class="p">(</span><span class="n">fatnewstree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;fatnewstree&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fatnewstree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fatnewstree</span> <span class="o">=</span> <span class="n">fatstree</span>  <span class="c1"># is this what we want?@@</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># insert the leftout words and adapt the begin/ends of the nodes</span>
                <span class="c1"># simpleshow(stree)</span>
                <span class="n">fatnewstree</span> <span class="o">=</span> <span class="n">insertskips</span><span class="p">(</span><span class="n">fatnewstree</span><span class="p">,</span> <span class="n">correctiontokenlist</span><span class="p">,</span> <span class="n">fatstree</span><span class="p">)</span>
                <span class="c1"># newstree = insertskips(newstree, correctiontokenlist, stree)</span>
                <span class="c1"># simpleshow(stree)</span>
                <span class="n">mdcopy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">origmetadata</span><span class="p">)</span>
                <span class="n">fatnewstree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mdcopy</span><span class="p">)</span>
                <span class="c1"># copy the sentid attribute</span>
                <span class="n">sentencenode</span> <span class="o">=</span> <span class="n">getsentencenode</span><span class="p">(</span><span class="n">fatnewstree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sentencenode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sentencenode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;sentid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sentid</span>
                <span class="k">if</span> <span class="n">debugb</span><span class="p">:</span>
                    <span class="n">showtree</span><span class="p">(</span><span class="n">fatnewstree</span><span class="p">)</span>
                <span class="c1"># etree.dump(fatnewstree)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make sure to include the xmeta from CHAT cleaning!! variable allmetadata, or better metadata but perhaps rename to chatmetadata</span>
            <span class="n">fatnewstree</span> <span class="o">=</span> <span class="n">add_metadata</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">chatmetadata</span><span class="p">)</span>

        <span class="n">ptmds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">correctionwordlist</span><span class="p">,</span> <span class="n">fatnewstree</span><span class="p">,</span> <span class="n">cwmdmetadata</span><span class="p">))</span>

    <span class="c1"># select the stree for the most promising correction</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;3:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;: &#39;</span><span class="p">)</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">fatnewstree</span><span class="p">)</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ptmds</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">thecorrection</span><span class="p">,</span> <span class="n">orandalts</span> <span class="o">=</span> <span class="p">(</span><span class="n">cleanutt</span><span class="p">,</span> <span class="n">fatstree</span><span class="p">,</span> <span class="n">origmetadata</span><span class="p">),</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">corr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">corr1</span><span class="p">,</span> <span class="n">corrn</span><span class="p">]:</span>
        <span class="n">thecorrection</span><span class="p">,</span> <span class="n">orandalts</span> <span class="o">=</span> <span class="n">selectcorrection</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">ptmds</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Illegal correction value: </span><span class="si">{}</span><span class="s1">. No corrections applied&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>
        <span class="n">thecorrection</span><span class="p">,</span> <span class="n">orandalts</span> <span class="o">=</span> <span class="p">(</span><span class="n">cleanutt</span><span class="p">,</span> <span class="n">fatstree</span><span class="p">,</span> <span class="n">origmetadata</span><span class="p">),</span> <span class="kc">None</span>

    <span class="n">thetree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">thecorrection</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># debuga = True</span>
    <span class="n">debuga</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debuga</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;4: (fatstree)&#39;</span><span class="p">)</span>
        <span class="n">etree</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># do replacements in the tree</span>
    <span class="k">if</span> <span class="n">debuga</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;4b: (thetree)&#39;</span><span class="p">)</span>
        <span class="n">etree</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">reverseposindex</span> <span class="o">=</span> <span class="n">gettokposlist</span><span class="p">(</span><span class="n">thetree</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debuga</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;4b: (thetree)&#39;</span><span class="p">)</span>
        <span class="n">etree</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># resultposmeta = selectmeta(&#39;cleanedtokenpositions&#39;, allmetadata)</span>
    <span class="c1"># resultposlist = resultposmeta.value</span>

    <span class="n">newcorrection2</span> <span class="o">=</span> <span class="n">thecorrection</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">nodes2deletebegins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PositionStr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># next adapted, the tree is fat already</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;thetree before treewithtokenpos&#39;</span><span class="p">)</span>
    <span class="n">thetree</span> <span class="o">=</span> <span class="n">treewithtokenpos</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">correctiontokenlist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;thetree after treewithtokenpos&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">thecorrection</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_node</span><span class="p">:</span>
            <span class="n">nodeend</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">annotationposlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">myfind</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="s1">&#39;.//node[@pt and @end=&quot;</span><span class="si">{}</span><span class="s1">&quot;]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nodeend</span><span class="p">))</span>
            <span class="n">oldnode</span> <span class="o">=</span> <span class="n">myfind</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="s1">&#39;.//node[@pt and @end=&quot;</span><span class="si">{}</span><span class="s1">&quot;]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nodeend</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">oldnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># adapt oldnode1 for contextual features</span>
                <span class="n">contextoldnode</span> <span class="o">=</span> <span class="n">contextualise</span><span class="p">(</span><span class="n">oldnode</span><span class="p">,</span> <span class="n">newnode</span><span class="p">)</span>
                <span class="n">thetree</span> <span class="o">=</span> <span class="n">transplant_node</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="n">contextoldnode</span><span class="p">,</span> <span class="n">thetree</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_word</span> <span class="ow">or</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_wordlemma</span><span class="p">:</span>
            <span class="n">nodeend</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">annotationposlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">nodexpath</span> <span class="o">=</span> <span class="s1">&#39;.//node[@pt and @begin=&quot;</span><span class="si">{}</span><span class="s1">&quot; and @end=&quot;</span><span class="si">{}</span><span class="s1">&quot;]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nodeend</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodeend</span><span class="p">)</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">myfind</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">nodexpath</span><span class="p">)</span>
            <span class="n">oldnode</span> <span class="o">=</span> <span class="n">myfind</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">nodexpath</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">oldnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;word&#39;</span> <span class="ow">in</span> <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="s1">&#39;word&#39;</span> <span class="ow">in</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                    <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;word&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;word&#39;</span><span class="p">]</span>
                    <span class="n">thetree</span> <span class="o">=</span> <span class="n">adaptsentence</span><span class="p">(</span><span class="n">thetree</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;word&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Unexpected missing &quot;word&quot; attribute in utterance </span><span class="si">{}</span><span class="s1">, node: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="p">))</span>
                        <span class="n">simpleshow</span><span class="p">(</span><span class="n">oldnode</span><span class="p">,</span> <span class="n">showchildren</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;word&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Unexpected missing &quot;word&quot; attribute in utterance </span><span class="si">{}</span><span class="s1">, node: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="p">))</span>
                        <span class="n">simpleshow</span><span class="p">(</span><span class="n">oldnode</span><span class="p">,</span> <span class="n">showchildren</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_wordlemma</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">newnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">oldnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;lemma&#39;</span> <span class="ow">in</span> <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="s1">&#39;lemma&#39;</span> <span class="ow">in</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                        <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lemma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lemma&#39;</span><span class="p">]</span>
                        <span class="n">thetree</span> <span class="o">=</span> <span class="n">adaptsentence</span><span class="p">(</span><span class="n">thetree</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s1">&#39;lemma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                            <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Unexpected missing &quot;lemma&quot; attribute in utterance </span><span class="si">{}</span><span class="s1">, node: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="p">))</span>
                            <span class="n">simpleshow</span><span class="p">(</span><span class="n">oldnode</span><span class="p">,</span> <span class="n">showchildren</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">if</span> <span class="s1">&#39;lemma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                            <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                                <span class="s1">&#39;Unexpected missing &quot;lemma&quot; attribute in utterance </span><span class="si">{}</span><span class="s1">, node </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="p">))</span>
                            <span class="n">simpleshow</span><span class="p">(</span><span class="n">oldnode</span><span class="p">,</span> <span class="n">showchildren</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_none</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_delete</span><span class="p">:</span>
            <span class="n">orignodebegin</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">annotatedposlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">nodes2deletebegins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orignodebegin</span><span class="p">)</span>  <span class="c1"># just gather the begin sof the nodes to be deleted</span>
        <span class="k">elif</span> <span class="n">meta</span><span class="o">.</span><span class="n">backplacement</span> <span class="o">==</span> <span class="n">bpl_indeze</span><span class="p">:</span>
            <span class="n">nodebegin</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">annotatedposlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">nodeend</span> <span class="o">=</span> <span class="n">nodebegin</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">oldnode</span> <span class="o">=</span> <span class="n">myfind</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="s1">&#39;.//node[@pt and @end=&quot;</span><span class="si">{}</span><span class="s1">&quot;]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nodeend</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">oldnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nodeid</span> <span class="o">=</span> <span class="n">oldnode</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
                <span class="n">dezeAVnode</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">dezeAVntemplate</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">begin</span><span class="o">=</span><span class="n">nodebegin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">nodeend</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">nodeid</span><span class="p">))</span>
                <span class="n">thetree</span> <span class="o">=</span> <span class="n">transplant_node</span><span class="p">(</span><span class="n">oldnode</span><span class="p">,</span> <span class="n">dezeAVnode</span><span class="p">,</span> <span class="n">thetree</span><span class="p">)</span>

        <span class="c1"># etree.dump(thetree, pretty_print=True)</span>

    <span class="c1"># now do all the deletions at once, incl adaptation of begins and ends, and new sentence node</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;thetree before deletion:&#39;</span><span class="p">)</span>

    <span class="n">nodes2deleteintbegins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nodes2deletebegins</span><span class="p">]</span>
    <span class="n">thetree</span> <span class="o">=</span> <span class="n">deletewordnodes</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">nodes2deleteintbegins</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">thetree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;thetree after deletion:&#39;</span><span class="p">)</span>

    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># adapt the metadata</span>
    <span class="n">cleantokposlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">annotationwordlist</span> <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">newcorrection2</span> <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;cleanedtokenpositions&#39;</span><span class="p">]</span>
    <span class="n">cleantokpos</span> <span class="o">=</span> <span class="n">cleantokposlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">cleantokposlist</span> <span class="o">!=</span> <span class="p">[]</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">insertbegins</span> <span class="o">=</span> <span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">annotatedposlist</span> <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">newcorrection2</span> <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">insertion</span><span class="p">]</span>
    <span class="n">flatinsertbegins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">insertbegins</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">el</span><span class="p">]</span>
    <span class="n">purenodes2deletebegins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodes2deletebegins</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flatinsertbegins</span><span class="p">]</span>
    <span class="n">newcorrection2</span> <span class="o">=</span> <span class="p">[</span><span class="n">updatecleantokmeta</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">purenodes2deletebegins</span><span class="p">,</span> <span class="n">cleantokpos</span><span class="p">)</span> <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">newcorrection2</span><span class="p">]</span>

    <span class="c1"># etree.dump(thetree, pretty_print=True)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">showtree</span><span class="p">(</span><span class="n">fatstree</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;5:&#39;</span><span class="p">)</span>

    <span class="n">restoredtree</span> <span class="o">=</span> <span class="n">thetree</span>

    <span class="c1"># add the metadata to the tree</span>
    <span class="n">fulltree</span> <span class="o">=</span> <span class="n">restoredtree</span>
    <span class="c1"># print(&#39;dump 1:&#39;)</span>
    <span class="c1"># etree.dump(fulltree, pretty_print=True)</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="n">fulltree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.//metadata&#39;</span><span class="p">)</span>
    <span class="c1"># remove the existing metadata</span>
    <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">getparent</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># insert the original metadata</span>

    <span class="k">if</span> <span class="n">origmetadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;metadata&#39;</span><span class="p">)</span>
        <span class="n">fulltree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fulltree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">origmetadata</span><span class="p">)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">origmetadata</span>

    <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">newcorrection2</span><span class="p">:</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">toElement</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">streesentlist</span> <span class="o">=</span> <span class="n">getyield</span><span class="p">(</span><span class="n">fatstree</span><span class="p">)</span>
        <span class="n">fulltreesentlist</span> <span class="o">=</span> <span class="n">getyield</span><span class="p">(</span><span class="n">fulltree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">streesentlist</span> <span class="o">!=</span> <span class="n">fulltreesentlist</span><span class="p">:</span>
            <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;Yield mismatch</span><span class="se">\n</span><span class="s1">Original=</span><span class="si">{original}</span><span class="se">\n</span><span class="s1">After correction=</span><span class="si">{newone}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">original</span><span class="o">=</span><span class="n">streesentlist</span><span class="p">,</span>
                                                                                        <span class="n">newone</span><span class="o">=</span><span class="n">fulltreesentlist</span><span class="p">))</span>
    <span class="n">rawoldleavenodes</span> <span class="o">=</span> <span class="n">getnodeyield</span><span class="p">(</span><span class="n">fatstree</span><span class="p">)</span>
    <span class="n">omittedwordbegins</span> <span class="o">=</span> <span class="n">getomittedwordbegins</span><span class="p">(</span><span class="n">newcorrection2</span><span class="p">)</span>
    <span class="n">oldleavenodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rawoldleavenodes</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">getattval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;begin&#39;</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">omittedwordbegins</span><span class="p">]</span>
    <span class="n">oldleaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">getattval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">oldleavenodes</span><span class="p">]</span>
    <span class="n">newleaves</span> <span class="o">=</span> <span class="n">getyield</span><span class="p">(</span><span class="n">fulltree</span><span class="p">)</span>
    <span class="n">uttid</span> <span class="o">=</span> <span class="n">getuttid</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">oldleaves</span> <span class="o">!=</span> <span class="n">newleaves</span><span class="p">:</span>
        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s1">&#39;Yield mismatch:</span><span class="si">{uttid}</span><span class="se">\n</span><span class="s1">:OLD=</span><span class="si">{oldleaves}</span><span class="se">\n</span><span class="s1">NEW=</span><span class="si">{newleaves}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uttid</span><span class="o">=</span><span class="n">uttid</span><span class="p">,</span> <span class="n">oldleaves</span><span class="o">=</span><span class="n">oldleaves</span><span class="p">,</span>
                                                                               <span class="n">newleaves</span><span class="o">=</span><span class="n">newleaves</span><span class="p">))</span>
    <span class="c1"># return this stree</span>
    <span class="c1"># print(&#39;dump 2:&#39;)</span>
    <span class="c1"># etree.dump(fulltree, pretty_print=True)</span>
    <span class="k">return</span> <span class="n">fulltree</span><span class="p">,</span> <span class="n">orandalts</span></div>


<span class="k">def</span> <span class="nf">getsentencenode</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SynTree</span><span class="p">:</span>
    <span class="n">sentnodes</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//sentence&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sentnodes</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">sentnodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">updatecleantokmeta</span><span class="p">(</span><span class="n">meta</span><span class="p">:</span> <span class="n">Meta</span><span class="p">,</span> <span class="n">begins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">cleantokpos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meta</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meta</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cleanedtokenisation&#39;</span><span class="p">,</span> <span class="s1">&#39;cleanedtokenpositions&#39;</span><span class="p">]:</span>
        <span class="n">sortedbegins</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">begins</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">newmeta</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">begin</span> <span class="ow">in</span> <span class="n">sortedbegins</span><span class="p">:</span>
            <span class="n">intbegin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span>
            <span class="n">beginindex</span> <span class="o">=</span> <span class="n">cleantokpos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">intbegin</span><span class="p">)</span>
            <span class="n">newmeta</span><span class="o">.</span><span class="n">annotationwordlist</span> <span class="o">=</span> <span class="n">newmeta</span><span class="o">.</span><span class="n">annotationwordlist</span><span class="p">[:</span><span class="n">beginindex</span><span class="p">]</span> \
                                         <span class="o">+</span> <span class="n">newmeta</span><span class="o">.</span><span class="n">annotationwordlist</span><span class="p">[</span><span class="n">beginindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">newmeta</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">newmeta</span><span class="o">.</span><span class="n">annotationwordlist</span>
        <span class="k">return</span> <span class="n">newmeta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">meta</span>


<span class="k">def</span> <span class="nf">oldgetuttid</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UttId</span><span class="p">:</span>
    <span class="n">uttidlist</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="n">uttidxpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">uttidlist</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">SDLOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Missing uttid&#39;</span><span class="p">)</span>
        <span class="n">uttid</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">uttid</span> <span class="o">=</span> <span class="n">uttidlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">uttid</span>


<span class="k">def</span> <span class="nf">getorigutt</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="n">origuttlist</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="n">origuttxpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">origuttlist</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">origutt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origutt</span> <span class="o">=</span> <span class="n">origuttlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">origutt</span>


<span class="k">def</span> <span class="nf">scorefunction</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Alternative</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple15int</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">unknownwordcount</span><span class="p">,</span> <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">dpcount</span><span class="p">,</span> <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">dhyphencount</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">goodcatcount</span><span class="p">,</span>
            <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">basicreplaceecount</span><span class="p">,</span> <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">ambigcount</span><span class="p">,</span> <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">hyphencount</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">dimcount</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">compcount</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">supcount</span><span class="p">,</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">compoundcount</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">sucount</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">svaok</span><span class="p">,</span> <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">deplusneutcount</span><span class="p">,</span> <span class="o">-</span><span class="n">obj</span><span class="o">.</span><span class="n">penalty</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">getbestaltids</span><span class="p">(</span><span class="n">alts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">AltId</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AltId</span><span class="p">]:</span>
    <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AltId</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">altid</span> <span class="ow">in</span> <span class="n">alts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">results</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">altid</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">alts</span><span class="p">[</span><span class="n">altid</span><span class="p">]</span><span class="o">.</span><span class="n">betterscorethan</span><span class="p">(</span><span class="n">alts</span><span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">altid</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">alts</span><span class="p">[</span><span class="n">altid</span><span class="p">]</span><span class="o">.</span><span class="n">equalscoreas</span><span class="p">(</span><span class="n">alts</span><span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">altid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span> <span class="nf">getsvaokcount</span><span class="p">(</span><span class="n">nt</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">subjects</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//node[@rel=&quot;su&quot;]&#39;</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">subject</span> <span class="ow">in</span> <span class="n">subjects</span><span class="p">:</span>
        <span class="n">pv</span> <span class="o">=</span> <span class="n">find1</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="s1">&#39;../node[@rel=&quot;hd&quot; and @pt=&quot;ww&quot; and @wvorm=&quot;pv&quot;]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phicompatible</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">pv</span><span class="p">):</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counter</span>


<span class="k">def</span> <span class="nf">getdeplusneutcount</span><span class="p">(</span><span class="n">nt</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">theyield</span> <span class="o">=</span> <span class="n">getnodeyield</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="n">ltheyield</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theyield</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ltheyield</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="n">theyield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">getattval</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="s1">&#39;lemma&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dets</span><span class="p">[</span><span class="n">de</span><span class="p">]:</span>
            <span class="n">node2</span> <span class="o">=</span> <span class="n">theyield</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">getattval</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
            <span class="n">parsedwordtree</span> <span class="o">=</span> <span class="n">PARSE_FUNC</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">parsedwordnode</span> <span class="o">=</span> <span class="n">find1</span><span class="p">(</span><span class="n">parsedwordtree</span><span class="p">,</span> <span class="s1">&#39;.//node[@pt]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parsedwordnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">getattval</span><span class="p">(</span><span class="n">parsedwordnode</span><span class="p">,</span> <span class="s1">&#39;genus&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;onz&#39;</span> <span class="ow">and</span> \
                    <span class="n">getattval</span><span class="p">(</span><span class="n">parsedwordnode</span><span class="p">,</span> <span class="s1">&#39;getal&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;ev&#39;</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counter</span>


<span class="n">validwords</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;z&#39;n&quot;</span><span class="p">}</span>
<span class="n">punctuationsymbols</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;.,?!:;&quot;&#39;&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">isvalidword</span><span class="p">(</span><span class="n">w</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">known_word</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">punctuationsymbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">validwords</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">countambigwords</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">leaves</span> <span class="o">=</span> <span class="n">getnodeyield</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="n">ambignodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">leave</span> <span class="k">for</span> <span class="n">leave</span> <span class="ow">in</span> <span class="n">leaves</span> <span class="k">if</span> <span class="n">getattval</span><span class="p">(</span><span class="n">leave</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">disambiguationdict</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ambignodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">selectcorrection</span><span class="p">(</span><span class="n">stree</span><span class="p">:</span> <span class="n">SynTree</span><span class="p">,</span> <span class="n">ptmds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ParsedCorrection</span><span class="p">],</span> <span class="n">corr</span><span class="p">:</span> <span class="n">CorrectionMode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">ParsedCorrection</span><span class="p">,</span> <span class="n">OrigandAlts</span><span class="p">]:</span>
    <span class="c1"># to be implemented@@</span>
    <span class="c1"># it is presupposed that ptmds is not []</span>

    <span class="n">uttid</span> <span class="o">=</span> <span class="n">getuttid</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
    <span class="n">orig</span> <span class="o">=</span> <span class="n">Original</span><span class="p">(</span><span class="n">uttid</span><span class="p">,</span> <span class="n">stree</span><span class="p">)</span>

    <span class="n">altid</span><span class="p">:</span> <span class="n">AltId</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">alts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">AltId</span><span class="p">,</span> <span class="n">Alternative</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cw</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">ptmds</span><span class="p">:</span>
        <span class="n">altsent</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cw</span><span class="p">)</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="n">compute_penalty</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
        <span class="n">dpcount</span> <span class="o">=</span> <span class="n">countav</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="s1">&#39;rel&#39;</span><span class="p">,</span> <span class="s1">&#39;dp&#39;</span><span class="p">)</span>
        <span class="n">dhyphencount</span> <span class="o">=</span> <span class="n">countav</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="s1">&#39;rel&#39;</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="n">dimcount</span> <span class="o">=</span> <span class="n">countav</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="s1">&#39;graad&#39;</span><span class="p">,</span> <span class="s1">&#39;dim&#39;</span><span class="p">)</span>
        <span class="n">compcount</span> <span class="o">=</span> <span class="n">countav</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="s1">&#39;graad&#39;</span><span class="p">,</span> <span class="s1">&#39;comp&#39;</span><span class="p">)</span>
        <span class="n">supcount</span> <span class="o">=</span> <span class="n">countav</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="s1">&#39;graad&#39;</span><span class="p">,</span> <span class="s1">&#39;sup&#39;</span><span class="p">)</span>
        <span class="n">compoundcount</span> <span class="o">=</span> <span class="n">getcompoundcount</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
        <span class="n">unknownwordcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">nt</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//node[@pt!=&quot;tsw&quot;]/@lemma&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isvalidword</span><span class="p">(</span><span class="n">w</span><span class="p">))])</span>
        <span class="n">sucount</span> <span class="o">=</span> <span class="n">countav</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="s1">&#39;rel&#39;</span><span class="p">,</span> <span class="s1">&#39;su&#39;</span><span class="p">)</span>
        <span class="n">svaokcount</span> <span class="o">=</span> <span class="n">getsvaokcount</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
        <span class="n">deplusneutcount</span> <span class="o">=</span> <span class="n">getdeplusneutcount</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
        <span class="n">goodcatcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nt</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//node[@cat and (@cat!=&quot;du&quot;)]&#39;</span><span class="p">)])</span>
        <span class="n">hyphencount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nt</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//node[contains(@word, &quot;-&quot;)]&#39;</span><span class="p">)])</span>
        <span class="n">basicreplaceecount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nt</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//node[@word]&#39;</span><span class="p">)</span>
                                  <span class="k">if</span> <span class="n">getattval</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">basicreplacements</span><span class="p">])</span>
        <span class="n">ambigwordcount</span> <span class="o">=</span> <span class="n">countambigwords</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="n">Alternative</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">altid</span><span class="p">,</span> <span class="n">altsent</span><span class="p">,</span> <span class="n">penalty</span><span class="p">,</span> <span class="n">dpcount</span><span class="p">,</span> <span class="n">dhyphencount</span><span class="p">,</span> <span class="n">dimcount</span><span class="p">,</span> <span class="n">compcount</span><span class="p">,</span> <span class="n">supcount</span><span class="p">,</span>
                          <span class="n">compoundcount</span><span class="p">,</span> <span class="n">unknownwordcount</span><span class="p">,</span> <span class="n">sucount</span><span class="p">,</span> <span class="n">svaokcount</span><span class="p">,</span> <span class="n">deplusneutcount</span><span class="p">,</span> <span class="n">goodcatcount</span><span class="p">,</span>
                          <span class="n">hyphencount</span><span class="p">,</span> <span class="n">basicreplaceecount</span><span class="p">,</span> <span class="n">ambigwordcount</span><span class="p">)</span>
        <span class="n">alts</span><span class="p">[</span><span class="n">altid</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt</span>
        <span class="n">altid</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">orandalts</span> <span class="o">=</span> <span class="n">OrigandAlts</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">alts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">corr</span> <span class="o">==</span> <span class="n">corr1</span><span class="p">:</span>
        <span class="n">orandalts</span><span class="o">.</span><span class="n">selected</span> <span class="o">=</span> <span class="n">altid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># @@to be implemented@@</span>
        <span class="n">orandalts</span><span class="o">.</span><span class="n">selected</span> <span class="o">=</span> <span class="n">altid</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">ptmds</span><span class="p">[</span><span class="n">orandalts</span><span class="o">.</span><span class="n">selected</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">orandalts</span>


<span class="k">def</span> <span class="nf">compute_penalty</span><span class="p">(</span><span class="n">md</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Meta</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Penalty</span><span class="p">:</span>
    <span class="n">totalpenalty</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
        <span class="n">totalpenalty</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">penalty</span>
    <span class="k">return</span> <span class="n">totalpenalty</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SASTA  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">correcttreebank</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Jan Odijk, Jelte van Boheemen, Martin Kroon.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>